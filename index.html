<!DOCTYPE html>
<html>
<head>
    <title>Pocket League</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #info {
            position: absolute; top: 10px; width: 100%; text-align: center; color: white;
            pointer-events: none; text-shadow: 1px 1px 2px black; z-index: 10;
        }
        #score { font-size: 40px; font-weight: bold; }
        .controls { font-size: 14px; color: #ccc; margin-top: 5px; }
        #cameraMode { 
            font-size: 18px; 
            margin-top: 5px; 
            padding: 5px 10px; 
            background-color: rgba(0, 0, 0, 0.5); 
            border-radius: 5px;
            display: inline-block;
        }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; }
    </style>
	<style>
    /* Disable text selection everywhere */
    * {
        -webkit-user-select: none;   /* iPad / Safari */
        -webkit-touch-callout: none; /* Disable longâ€‘press menu */
        user-select: none;           /* Standard */
    }

    /* Remove Safari tap highlight */
    body {
        -webkit-tap-highlight-color: transparent;
    }

    /* Optional: stop scrolling / pinch zoom */
    html, body {
        touch-action: none;
    }


#joystick {
    position: fixed;
    width: 140px;
    height: 140px;
    background: rgba(255,255,255,0.1);
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 50%;
    pointer-events: none;
    touch-action: none;
}

#stick {
    position: absolute;
    width: 60px;
    height: 60px;
    background: rgba(255,255,255,0.3);
    border-radius: 50%;
    left: 40px;
    top: 40px;
    transform: translate(0, 0);
    pointer-events: none;
}
	
</style>
</head>
<body>

<div id="menuOverlay">
    <div id="menuBox">
        <h1>Pocket League</h1>
        <button id="FreeplayBtn">Freeplay</button>
	<button id="1v1Btn">Bot 1v1</button>
        <button id="settingsBtn">Settings</button>
        <button id="quitBtn">Quit</button>
    </div>
</div>

<style>
#menuOverlay {
    position: absolute;
    top:0; left:0;
    width:100%; height:100%;
    background: rgba(0,0,0,0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 20;
}
#menuBox {
    background: #111122;
    padding: 30px 50px;
    border-radius: 12px;
    text-align: center;
    color: #fff;
    box-shadow: 0 0 20px #000;
}
#menuBox h1 {
    margin-bottom: 20px;
    font-size: 36px;
    color: #4488FF;
}
#menuBox button {
    display: block;
    width: 200px;
    margin: 10px auto;
    padding: 10px;
    font-size: 18px;
    border: none;
    border-radius: 6px;
    background: #4488FF;
    color: #fff;
    cursor: pointer;
    transition: all 0.2s;
}
#menuBox button:hover {
    background: #66aaff;
    transform: scale(1.05);
}
</style>


<div id="info">
    <div id="score"><span style="color:#4488FF">BLUE: 0</span> - <span style="color:#FF8833">ORANGE: 0</span></div>
    <div class="controls">
        <b>KBM:</b> WASD / ARROWS to Drive | <b>Q/E</b> for Air Roll | <b>SPACE (x2)</b> to Jump/Flip | <b>SHIFT</b> to Boost | <b>ENTER</b> to Switch Camera | R to Reset<br>
        <b>Controller:</b> Left Stick to Drive/Steer | <b>A/X</b> to Jump/Flip | <b>RT/R2</b> to Boost | <b>LB/RB</b> for Air Roll | <b>X/Square</b> to Switch Camera
    </div>
    <div id="cameraMode">Camera: Car Cam</div>
</div>
<div id="loading">Loading Engine...</div>

<div id="joystick" style="display:none; position:fixed; bottom:20px; left:20px;">
    <div id="stick"></div>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

<script>
    // --- CONFIGURATION ---
    const SCALE_FACTOR = 4;
    const FIELD_W = 60 * SCALE_FACTOR;    
    const FIELD_L = 100 * SCALE_FACTOR;  
    const ARENA_HEIGHT = 80;    
    const GOAL_WIDTH = 50;    
    const GOAL_DEPTH = 10;
    const GOAL_HEIGHT = 25;
    const CAR_SIZE = { w: 2, h: 1, l: 4 };
    const BALL_RADIUS = 5;    
    
    // NEW CONSTANT FOR WALLS
    const WALL_THICKNESS = 5;    
    
    // Derived Constants
    const BACKBOARD_HEIGHT = GOAL_HEIGHT * 2.5;    
    const END_WALL_LENGTH = (FIELD_W - GOAL_WIDTH) / 2;
    
    // --- GLOBALS ---
    let flipTimer = 0;
    let isFlipping = false;
    let scene, camera, renderer;
    let world, physicsMaterials = {};
    let carBody, carMesh, ballBody, ballMesh;
    let cameraYaw = 0;
    let flipAxis = new CANNON.Vec3();
    let cameraYawDir = new THREE.Vector3(0, 0, -1);
    let replayTimer = 0;
    let replayGoalPos = new THREE.Vector3();
    let replayBuffer = [];    // stores recorded frames
    let replayFrames = [];    // **NEW:** The array used for playback (initialized in score())
    let replayIndex = 0;      // current frame for replay
    let isRecordingReplay = false;
    let isReplaying = false;
    const REPLAY_LENGTH = 5; // seconds to replay
    const REPLAY_FPS = 60;    // how many frames per second
    let gameStarted = false;
    let botBody, botMesh;
    let gameMode = 'freeplay';
	let mobileControlsEnabled = false;

    // NEW GLOBAL FOR GAMEPAD
    let gamepad; 

    let botInputs = {
        up: false,
        down: false,
        left: false,
        right: false,
        shift: false
    };

    // TWEAK 1: Update inputs to include analog values
    let inputs = { 
        // KBM Digital Inputs (set by keyboard handler)
        up: false, down: false, left: false, right: false, space: false, shift: false,
        q: false, e: false, enter: false,
        
        // Analog Inputs (set by joystick/gamepad handler, 0.0 to 1.0 or -1.0 to 1.0)
        driveAnalog: 0.0, // -1.0 (reverse) to 1.0 (forward)
        steerAnalog: 0.0, // -1.0 (left) to 1.0 (right)
        
        // Aerial flags
        W_aerialReady: false, S_aerialReady: false, A_aerialReady: false,
        D_aerialReady: false, Q_aerialReady: false, E_aerialReady: false  
    };
    
    let scores = { blue: 0, orange: 0 };
    let gameState = 'playing';

    let cameraMode = 'car'; // 'car' or 'ball'

    // --- AIRDODGE GLOBALS ---
    let lastJumpTime = 0;
    const DOUBLE_JUMP_LOCKOUT = 1.25;    
    let hasDoubleJumped = false;
    const FLIP_IMPULSE = 35 * SCALE_FACTOR;
    const FORWARD_FLIP_IMPULSE = 45 * SCALE_FACTOR;    
    const FLIP_ROTATION = 1.0;    
    
    // MOVEMENT CONSTANTS
    const BASE_SPEED = 20 * SCALE_FACTOR;
    const BOOST_SPEED = 20 * SCALE_FACTOR;    
    const TURN_RATE = 0.032;    
    const JUMP_VELOCITY = 30 * Math.sqrt(SCALE_FACTOR);    
    const BOOST_VELOCITY_ADD = 1 * SCALE_FACTOR;    
    
    const BLUE_GOAL_LINE = -FIELD_L/2;
    const ORANGE_GOAL_LINE = FIELD_L/2;

    init();
    animate();

    function init() {
        // 1. SETUP THREE.JS
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0A0A1F);    
        scene.fog = new THREE.Fog(0x0A0A1F, FIELD_L * 0.4, FIELD_L * 1.5);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // LIGHTING
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x112211, 1.0);    
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -FIELD_W / 2;
        dirLight.shadow.camera.right = FIELD_W / 2;
        dirLight.shadow.camera.top = FIELD_L / 2;
        dirLight.shadow.camera.bottom = -FIELD_L / 2;
        scene.add(dirLight);

        // 2. SETUP CANNON.JS PHYSICS
        world = new CANNON.World();
        world.gravity.set(0, -150, 0);    
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Materials
        const groundMat = new CANNON.Material();
        const objMat = new CANNON.Material();
        
        // --- ZERO GROUND FRICTION ---
        const objContactMat = new CANNON.ContactMaterial(groundMat, objMat, { friction: 0.0, restitution: 0.5 });    
        const ballContactMat = new CANNON.ContactMaterial(objMat, objMat, { friction: 0.0, restitution: 0.55 });    

        world.addContactMaterial(objContactMat);
        world.addContactMaterial(ballContactMat);

        physicsMaterials = { ground: groundMat, object: objMat };

        // 3. BUILD WORLD
        createField();
        createCeiling();    
        createCar();    
        createBall();
        createScenery();    

        // 4. EVENTS
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', (e) => handleKey(e, true));
        window.addEventListener('keyup', (e) => handleKey(e, false));
        
        setupMobileControls(); 
        setupGamepadListeners(); // ADD GAMEPAD LISTENERS
        
        document.getElementById('loading').style.display = 'none';
    }

    // Helper function for static boundaries (used for walls and backboards)
    function createBoundary(x, y, z, w, h, d, color = 0xAAAAAA, opacity = 0.1, visible = true) {
        const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
        const body = new CANNON.Body({ mass: 0, material: physicsMaterials.object });
        body.addShape(shape);
        // Position Y is y + h/2 (where y is the ground level 0)
        body.position.set(x, y + h/2, z);
        body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), 0); // Ensure orientation is set
        world.addBody(body);
        
        const geo = new THREE.BoxGeometry(w, h, d);
        let mat;
        if (visible) {
            mat = new THREE.MeshStandardMaterial({ color: color, transparent: true, opacity: opacity, side: THREE.DoubleSide });
        } else {
            mat = new THREE.MeshBasicMaterial({ visible: false });
        }
        
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(body.position);
        mesh.receiveShadow = visible;
        scene.add(mesh);
    }

    function createScenery() {
        const sceneryHeight = ARENA_HEIGHT * 4;    
        const sceneryGroundColor = 0x113309;    
        const sceneryTreeColor = 0x114411;    
        const offset = 100;    
        const totalLength = FIELD_L * 2;
        const totalWidth = FIELD_W * 2;

        const outerGroundGeo = new THREE.PlaneGeometry(FIELD_W * 5, FIELD_L * 5);
        const outerGroundMat = new THREE.MeshStandardMaterial({ color: sceneryGroundColor, roughness: 0.8, side: THREE.DoubleSide });
        const outerGround = new THREE.Mesh(outerGroundGeo, outerGroundMat);
        outerGround.rotation.x = -Math.PI / 2;
        outerGround.position.y = -5;    
        outerGround.receiveShadow = true;
        scene.add(outerGround);

        const treeDensity = 20;    
        const treeRadius = 5;
        const treeGeo = new THREE.CylinderGeometry(treeRadius, treeRadius, sceneryHeight, 8);
        const treeMat = new THREE.MeshStandardMaterial({ color: sceneryTreeColor });

        for (let i = 0; i < treeDensity; i++) {
            const z = -totalLength / 2 + i * (totalLength / (treeDensity - 1));
            const meshL = new THREE.Mesh(treeGeo, treeMat);
            meshL.position.set(-FIELD_W / 2 - offset, sceneryHeight / 2, z);
            scene.add(meshL);
            const meshR = new THREE.Mesh(treeGeo, treeMat);
            meshR.position.set(FIELD_W / 2 + offset, sceneryHeight / 2, z);
            scene.add(meshR);
        }

        for (let i = 0; i < treeDensity; i++) {
            const x = -totalWidth / 2 + i * (totalWidth / (treeDensity - 1));
            const meshB = new THREE.Mesh(treeGeo, treeMat);
            meshB.position.set(x, sceneryHeight / 2, -FIELD_L / 2 - offset);
            scene.add(meshB);
            const meshO = new THREE.Mesh(treeGeo, treeMat);
            meshO.position.set(x, sceneryHeight / 2, FIELD_L / 2 + offset);
            scene.add(meshO);
        }
    }

    // Goal Net Visual (NOT the solid backboard)
    function createGoal(isBlue) {
        const GOAL_Z_START = isBlue ? BLUE_GOAL_LINE : ORANGE_GOAL_LINE;
        
        const netZ = GOAL_Z_START + (isBlue ? -GOAL_DEPTH/2 : GOAL_DEPTH/2);
        const geo = new THREE.BoxGeometry(GOAL_WIDTH, GOAL_HEIGHT, GOAL_DEPTH);
        const color = isBlue ? 0x0044FF : 0xFF8800;
        const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5, transparent: true, opacity: 0.3 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(0, GOAL_HEIGHT/2, netZ);
        scene.add(mesh);
    }

    function createCeiling() {
        const CEILING_X_VISUAL = FIELD_W + WALL_THICKNESS * 2;    
        // Calculate the required Z length based on the new wall positions
        const CEILING_Z_VISUAL = FIELD_L + GOAL_DEPTH * 2 + WALL_THICKNESS;    

        const ceilingGeo = new THREE.PlaneGeometry(CEILING_X_VISUAL, CEILING_Z_VISUAL);
        const ceilingMat = new THREE.MeshBasicMaterial({ color: 0x444488, transparent: true, opacity: 0.1, side: THREE.DoubleSide });
        const ceilingMesh = new THREE.Mesh(ceilingGeo, ceilingMat);
        ceilingMesh.rotation.x = Math.PI / 2;
        ceilingMesh.position.y = ARENA_HEIGHT;
        scene.add(ceilingMesh);

        const ceilingShape = new CANNON.Plane();
        const ceilingBody = new CANNON.Body({ mass: 0, material: physicsMaterials.object });
        ceilingBody.addShape(ceilingShape);
        
        ceilingBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
        ceilingBody.position.y = ARENA_HEIGHT;
        world.addBody(ceilingBody);
    }


    function createField() {
        // 1. GROUND PLANE
        const geometry = new THREE.PlaneGeometry(FIELD_W, FIELD_L);
        const material = new THREE.MeshStandardMaterial({ color: 0x103309, roughness: 0.8, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(geometry, material);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: physicsMaterials.ground });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(groundBody);
        
        // --- 2. STRAIGHT VERTICAL WALLS ---
        
        const WALL_HEIGHT = ARENA_HEIGHT;
        const HALF_WALL_THICKNESS = WALL_THICKNESS / 2;
        const HALF_FIELD_W = FIELD_W / 2;
        const HALF_GOAL_WIDTH = GOAL_WIDTH / 2;

        // A. SIDE WALLS (+X and -X)
        // Total side wall length must cover the FIELD_L plus the two goal enclosures and the wall thickness at the ends.
        const TOTAL_SIDE_WALL_LENGTH = FIELD_L + GOAL_DEPTH * 2 + WALL_THICKNESS;    
        
        // Right Side (+X) - centered at Z=0
        createBoundary(HALF_FIELD_W + HALF_WALL_THICKNESS, 0, 0, WALL_THICKNESS, WALL_HEIGHT, TOTAL_SIDE_WALL_LENGTH, 0xAAAAAA, 0.2, true);    
        // Left Side (-X) - centered at Z=0
        createBoundary(-HALF_FIELD_W - HALF_WALL_THICKNESS, 0, 0, WALL_THICKNESS, WALL_HEIGHT, TOTAL_SIDE_WALL_LENGTH, 0xAAAAAA, 0.2, true);    

        // B. END WALLS & BACKBOARDS (+Z and -Z)
        
        // Z-positions for all end walls (centered)
        const ORANGE_END_Z_CENTER = ORANGE_GOAL_LINE + GOAL_DEPTH + HALF_WALL_THICKNESS;    
        const BLUE_END_Z_CENTER = BLUE_GOAL_LINE - GOAL_DEPTH - HALF_WALL_THICKNESS;
        
        // Calculations for the split end walls (the non-goal sections)
        const W_split = (FIELD_W - GOAL_WIDTH) / 2;
        // The width of the split wall piece, extended to meet the side wall by WALL_THICKNESS
        const W_split_final = W_split + WALL_THICKNESS;    
        
        // Center X for the split walls, which is halfway between the goal edge (GOAL_WIDTH/2) and the outer arena edge (FIELD_W/2 + WALL_THICKNESS/2)
        const baseSplitCenter = HALF_GOAL_WIDTH + W_split / 2;
        
        const rightSplitXCenter = baseSplitCenter + HALF_WALL_THICKNESS / 2;
        const leftSplitXCenter = -baseSplitCenter - HALF_WALL_THICKNESS / 2;
        
        // --- ORANGE END (+Z) WALLS ---
        const orangeBackboardColor = 0xFF8800;
        
        // Backboard (Goal Area) - Width: GOAL_WIDTH, Centered at X=0
        createBoundary(0, 0, ORANGE_END_Z_CENTER, GOAL_WIDTH, WALL_HEIGHT, WALL_THICKNESS, orangeBackboardColor, 0.5, true);    
        
        // Right Side Wall Piece (Beside Goal)    
        createBoundary(rightSplitXCenter, 0, ORANGE_END_Z_CENTER, W_split_final, WALL_HEIGHT, WALL_THICKNESS, 0xAAAAAA, 0.2, true);
        
        // Left Side Wall Piece (Beside Goal)    
        createBoundary(leftSplitXCenter, 0, ORANGE_END_Z_CENTER, W_split_final, WALL_HEIGHT, WALL_THICKNESS, 0xAAAAAA, 0.2, true);

        
        // --- BLUE END (-Z) WALLS ---
        const blueBackboardColor = 0x0044FF;

        // Backboard (Goal Area) - Width: GOAL_WIDTH, Centered at X=0
        createBoundary(0, 0, BLUE_END_Z_CENTER, GOAL_WIDTH, WALL_HEIGHT, WALL_THICKNESS, blueBackboardColor, 0.5, true);    

        // Right Side Wall Piece (Beside Goal)
        createBoundary(rightSplitXCenter, 0, BLUE_END_Z_CENTER, W_split_final, WALL_HEIGHT, WALL_THICKNESS, 0xAAAAAA, 0.2, true);
        
        // Left Side Wall Piece (Beside Goal)
        createBoundary(leftSplitXCenter, 0, BLUE_END_Z_CENTER, W_split_final, WALL_HEIGHT, WALL_THICKNESS, 0xAAAAAA, 0.2, true);
        
        // 3. Goal Net Visuals
        createGoal(true);
        createGoal(false);
    }

    function createCar() {
        const shape = new CANNON.Box(new CANNON.Vec3(CAR_SIZE.w, CAR_SIZE.h, CAR_SIZE.l));
        carBody = new CANNON.Body({ mass: 150 * SCALE_FACTOR, material: physicsMaterials.object });    
        carBody.addShape(shape);
        // Correct Player Car (Blue) spawn to -Z side
        carBody.position.set(0, 2, -FIELD_L * 0.3);
        carBody.linearDamping = 0.01;    
        carBody.angularDamping = 0.9;
        world.addBody(carBody);

        carMesh = new THREE.Group();
        
        const bodyGeo = new THREE.BoxGeometry(CAR_SIZE.w * 2, CAR_SIZE.h * 2, CAR_SIZE.l * 2);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x3388FF });
        const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
        bodyMesh.castShadow = true;
        carMesh.add(bodyMesh);

        const roofGeo = new THREE.BoxGeometry(3.5, 0.5, 2);
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.position.y = 1;
        roof.position.z = -1;
        carMesh.add(roof);

        const wheelGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 12);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const positions = [[-2, -1, 2], [2, -1, 2], [-2, -1, 2], [2, -1, -2]];
        positions.forEach(pos => {
            const w = new THREE.Mesh(wheelGeo, wheelMat);
            w.rotation.z = Math.PI / 2;
            w.position.set(...pos);
            carMesh.add(w);
        });
        
        scene.add(carMesh);
    }

    function createBotCar() {
        const shape = new CANNON.Box(
            new CANNON.Vec3(CAR_SIZE.w, CAR_SIZE.h, CAR_SIZE.l)
        );

        botBody = new CANNON.Body({
            mass: 150 * SCALE_FACTOR,
            material: physicsMaterials.object
        });

        botBody.addShape(shape);
        // Correct Bot Car (Orange) spawn to +Z side
        botBody.position.set(0, 2, FIELD_L * 0.3);
        botBody.linearDamping = 0.01;
        botBody.angularDamping = 0.9;
        world.addBody(botBody);

        // MESH SETUP (Added roof and wheels for visibility)
        botMesh = new THREE.Group();

        const bodyGeo = new THREE.BoxGeometry(
            CAR_SIZE.w * 2,
            CAR_SIZE.h * 2,
            CAR_SIZE.l * 2
        );
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0xFF8833 }); // Orange color
        const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
        bodyMesh.castShadow = true;
        botMesh.add(bodyMesh);
        
        // Add Roof
        const roofGeo = new THREE.BoxGeometry(3.5, 0.5, 2);
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x222222 });    
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.position.y = 1;
        roof.position.z = -1;
        botMesh.add(roof);

        // Add Wheels
        const wheelGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 12);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const positions = [[-2, -1, 2], [2, -1, 2], [-2, -1, -2], [2, -1, -2]];
        positions.forEach(pos => {
            const w = new THREE.Mesh(wheelGeo, wheelMat);
            w.rotation.z = Math.PI / 2;
            w.position.set(...pos);
            botMesh.add(w);
        });

        scene.add(botMesh);
    }

    // Controls logic now mixes KBM and Gamepad inputs, with analog priority.
    function applyCarControls(body, controlInputs) {
        const isCarOnGround = body.position.y < (CAR_SIZE.h * 1.5);
        const forwardVector = new CANNON.Vec3(0, 0, -1);
        const rotatedForward = body.quaternion.vmult(forwardVector);

        // --- 1. Calculate Combined Drive Factor (Analog Priority) ---
        let driveFactor = 0; // -1.0 (reverse) to 1.0 (forward)
        
        if (Math.abs(controlInputs.driveAnalog) > 0.05) {
            driveFactor = controlInputs.driveAnalog; // Use analog value (Mobile or Gamepad)
            // Analog drive is full speed (1.0) for forward, half speed (-0.5) for reverse
            if (driveFactor < 0) {
                driveFactor *= 0.5; // Half speed for reverse
            }
        } else if (controlInputs.up) {
            driveFactor = 1.0; // Digital forward
        } else if (controlInputs.down) {
            driveFactor = -0.5; // Digital reverse (half speed)
        }
        
        // Apply speed based on the combined drive factor
        const targetSpeed = BASE_SPEED * driveFactor; 

        const targetVelocity = rotatedForward.scale(targetSpeed);
        const accelFactor = 0.05;

        // Smoothly apply acceleration
        body.velocity.x = body.velocity.x * (1 - accelFactor) + targetVelocity.x * accelFactor;
        body.velocity.z = body.velocity.z * (1 - accelFactor) + targetVelocity.z * accelFactor;

        // 2. Boost as Velocity Addition
        if (controlInputs.shift) {
            const boostImpulse = rotatedForward.scale(BOOST_VELOCITY_ADD);
            body.velocity.vadd(boostImpulse, body.velocity);
        }
        
        // 3. Ground Steering (Yaw rotation)
        if (isCarOnGround) {
            // --- Calculate Combined Steer Factor (Analog Priority) ---
            let steerFactor = 0; // -1.0 (left) to 1.0 (right)
            
            if (Math.abs(controlInputs.steerAnalog) > 0.05) {
                steerFactor = controlInputs.steerAnalog; // Use analog value (Mobile or Gamepad)
            } else {
                steerFactor = (controlInputs.left ? 1 : 0) - (controlInputs.right ? 1 : 0); // Digital value (KBM)
            }

            if (steerFactor !== 0) {
                const speed = Math.sqrt(
                    body.velocity.x ** 2 +
                    body.velocity.z ** 2
                );

                if (speed > 0.2) {
                    // Apply the analog/digital factor to the steering strength
                    const turnStrength = steerFactor * TURN_RATE * (speed / BASE_SPEED);

                    const rot = new CANNON.Quaternion();
                    rot.setFromAxisAngle(
                        new CANNON.Vec3(0, 1, 0),
                        turnStrength
                    );

                    body.quaternion = rot.mult(body.quaternion);
                }
            }

            // 4. Ground Grip (Dampens side slide)
            const rightVector = body.quaternion.vmult(new CANNON.Vec3(1, 0, 0));
            const sideSpeed = body.velocity.dot(rightVector);
            const SIDE_GRIP = 0.8; 
            body.velocity.vsub(
                rightVector.scale(sideSpeed * SIDE_GRIP),
                body.velocity
            );
        }
    }

    function createBall() {
        const shape = new CANNON.Sphere(BALL_RADIUS);
        ballBody = new CANNON.Body({ mass: 10 * SCALE_FACTOR, material: physicsMaterials.object });
        ballBody.addShape(shape);
        ballBody.position.set(0, BALL_RADIUS * 2, 0);    
        ballBody.linearDamping = 0.1;
        ballBody.angularDamping = 0.1;
        world.addBody(ballBody);

        const geo = new THREE.SphereGeometry(BALL_RADIUS, 16, 16);
        const mat = new THREE.MeshStandardMaterial({ color: 0xEEEEEE, roughness: 0.2, metalness: 0.1 });
        ballMesh = new THREE.Mesh(geo, mat);
        ballMesh.castShadow = true;
        scene.add(ballMesh);

        const light = new THREE.PointLight(0xffffff, 0.5, 20);
        ballMesh.add(light);
    }

    // MODIFIED: airDodge now uses analog stick input for directional flips.
    function airDodge() {
        const currentTime = performance.now() / 1000;
        if (currentTime - lastJumpTime > DOUBLE_JUMP_LOCKOUT || hasDoubleJumped) return;

        hasDoubleJumped = true;
        isFlipping = true;
        flipTimer = 0.4; // seconds (Rocket League-like)

        carBody.angularDamping = 0.05;

        const forward = new CANNON.Vec3(0, 0, -1);
        const right = new CANNON.Vec3(1, 0, 0); 

        // Get car orientation vectors
        const f = carBody.quaternion.vmult(forward);
        const r = carBody.quaternion.vmult(right);

        flipAxis.set(0, 0, 0);

        // --- ANALOG INPUT PRIORITY FOR FLIP DIRECTION ---
        // Check magnitude of analog stick displacement
        const stickMagnitude = Math.sqrt(inputs.driveAnalog * inputs.driveAnalog + inputs.steerAnalog * inputs.steerAnalog);
        
        if (stickMagnitude > 0.4) {
            // Calculate local impulse vector based on analog stick
            const localImpulseX = inputs.steerAnalog;   // X-axis (Right/Left)
            const localImpulseZ = -inputs.driveAnalog;  // Y-axis (Forward/Backward)
            
            const carLocalImpulse = new CANNON.Vec3(localImpulseX, 0, localImpulseZ);
            
            // Rotate the impulse vector by the car's quaternion to get world impulse
            const worldImpulse = carBody.quaternion.vmult(carLocalImpulse);
            worldImpulse.normalize(); // Normalize the direction

            // Apply velocity boost
            carBody.velocity.vadd(worldImpulse.scale(FORWARD_FLIP_IMPULSE), carBody.velocity);

            // Calculate flip axis (perpendicular to impulse direction)
            const upVector = new CANNON.Vec3(0, 1, 0);
            const localFlipAxis = new CANNON.Vec3();
            upVector.cross(carLocalImpulse, localFlipAxis);
            
            // Rotate the flip axis into world space and apply rotation
            carBody.quaternion.vmult(localFlipAxis, flipAxis);
            
            carBody.angularVelocity.set(
                flipAxis.x * 12,
                flipAxis.y * 12,
                flipAxis.z * 12
            );
            
        } else if (inputs.up) { // Digital front flip fallback
            flipAxis.copy(r).scale(-1); // Pitch down axis
            carBody.velocity.vadd(f.scale(FORWARD_FLIP_IMPULSE), carBody.velocity);
            carBody.angularVelocity.set(flipAxis.x * 12, flipAxis.y * 12, flipAxis.z * 12);
            
        } else {
            // Simple second jump if no direction input is provided
            carBody.velocity.y += JUMP_VELOCITY * 0.5;
            isFlipping = false;
            return;
        }
    }

    
    function handleKey(e, isDown) {
        const wasSpaceDown = inputs.space;
        const key = e.key.toLowerCase();
        const isCarAirborne = carBody.position.y >= (CAR_SIZE.h * 1.5);
        
        function updateAerialReady(keyName, keyState) {
            const flagName = `${keyName}_aerialReady`;
            if (keyState && isCarAirborne) {
                inputs[flagName] = true;
            } else if (!keyState) {
                inputs[flagName] = false;
            }
        }

        switch(key) {
            case 'w': case 'arrowup':    
                inputs.up = isDown;    
                updateAerialReady('W', isDown);
                break;
            case 's': case 'arrowdown':    
                inputs.down = isDown;    
                updateAerialReady('S', isDown);
                break;
            case 'a': case 'arrowleft':    
                inputs.left = isDown;    
                updateAerialReady('A', isDown);
                break;
            case 'd': case 'arrowright':    
                inputs.right = isDown;    
                updateAerialReady('D', isDown);
                break;
            case 'q':    
                inputs.q = isDown;    
                updateAerialReady('Q', isDown);
                break;
            case 'e':    
                inputs.e = isDown;    
                updateAerialReady('E', isDown);
                break;
            case ' ': inputs.space = isDown; break;
            case 'shift': inputs.shift = isDown; break;
            case 'enter':    
                if (isDown) {
                    cameraMode = (cameraMode === 'car') ? 'ball' : 'car';
                    document.getElementById('cameraMode').textContent = `Camera: ${cameraMode === 'car' ? 'Car Cam' : 'Ball Cam'}`;
                }
                break;
            case 'r': if(isDown) resetGame(); break;
        }

        const isCarOnGround = carBody.position.y < (CAR_SIZE.h * 1.5);
        const currentTime = performance.now() / 1000;
        
        if (inputs.space && !wasSpaceDown && isCarOnGround) {    
            carBody.velocity.y = JUMP_VELOCITY;
            lastJumpTime = currentTime;
            
            // Clear digital flags that would trigger a flip if held down
            inputs.W_aerialReady = inputs.up ? false : inputs.W_aerialReady;
            inputs.S_aerialReady = inputs.down ? false : inputs.S_aerialReady;
            inputs.A_aerialReady = inputs.left ? false : inputs.A_aerialReady;
            inputs.D_aerialReady = inputs.up ? false : inputs.D_aerialReady;
            inputs.Q_aerialReady = inputs.q ? false : inputs.Q_aerialReady;
            inputs.E_aerialReady = inputs.e ? false : inputs.E_aerialReady;
        }

        if (inputs.space && !wasSpaceDown) {
             if (!isCarOnGround && currentTime - lastJumpTime < DOUBLE_JUMP_LOCKOUT && !hasDoubleJumped) {
                 airDodge();
             }
        }
    }

    // MODIFIED: resetGame now clears analog inputs.
    function resetGame() {
        // Correct Player Car (Blue) spawn to -Z side
        carBody.position.set(0, 2, -FIELD_L * 0.3);
        carBody.velocity.set(0, 0, 0);
        carBody.quaternion.set(0, 0, 0, 1);
        carBody.angularVelocity.set(0, 0, 0);

        ballMesh.visible = true;
        ballBody.collisionFilterGroup = 1; // re-enable collisions


        ballBody.position.set(0, BALL_RADIUS * 2, 0);    
        ballBody.velocity.set(0, 0, 0);
        ballBody.angularVelocity.set(0, 0, 0);

        if (botBody) {
             // Correct Bot Car (Orange) spawn to +Z side
             botBody.position.set(0, 2, FIELD_L * 0.3);
             botBody.velocity.set(0, 0, 0);
             botBody.quaternion.set(0, 0, 0, 1);
             botBody.angularVelocity.set(0, 0, 0);
        }
        
       isFlipping = false;
       flipTimer = 0;
       flipAxis.set(0, 0, 0);
       carBody.angularDamping = 0.9;

	resetCameraInstant();

        lastJumpTime = 0;
        hasDoubleJumped = false;
        
        // Reset analog and digital inputs on game reset
        inputs.driveAnalog = 0.0;
        inputs.steerAnalog = 0.0;
        inputs.up = false;
        inputs.down = false;
        inputs.left = false;
        inputs.right = false;
        inputs.space = false;
        inputs.shift = false;
        inputs.q = false;
        inputs.e = false;
        
        gameState = 'playing';
        
        inputs.W_aerialReady = false;
        inputs.S_aerialReady = false;
        inputs.A_aerialReady = false;
        inputs.D_aerialReady = false;
        inputs.Q_aerialReady = false;
        inputs.E_aerialReady = false;
        
        // Clear replay array when game resets
        replayFrames = [];
    }

    function checkGoal() {
        if (gameState !== 'playing') return;

        const ballX = ballBody.position.x;
        const ballZ = ballBody.position.z;
        const ballY = ballBody.position.y;
        const goalRange = GOAL_WIDTH / 2;    

        // The check still uses the original GOAL_LINE positions, defining the scoring zone.
        if (ballZ < BLUE_GOAL_LINE && Math.abs(ballX) < goalRange && ballY < GOAL_HEIGHT) {
            score('orange');
        }    
        else if (ballZ > ORANGE_GOAL_LINE && Math.abs(ballX) < goalRange && ballY < GOAL_HEIGHT) {
            score('blue');
        }
    }

    function score(team) {
        const goalZ = team === 'blue' ? ORANGE_GOAL_LINE : BLUE_GOAL_LINE;
        const goalColor = team === 'blue' ? 0x4488FF : 0xFF8833;

        // Spawn goal explosion
        createGoalExplosion(new THREE.Vector3(0, GOAL_HEIGHT / 2, goalZ), goalColor);

        // Hide ball & disable collisions
        ballMesh.visible = false;
        ballBody.collisionFilterGroup = 0;

        // Record goal position for replay
        replayGoalPos.set(0, GOAL_HEIGHT / 2, goalZ);

        // Update scores
        scores[team]++;
        document.getElementById('score').innerHTML =
            `<span style="color:#4488FF">BLUE: ${scores.blue}</span> - <span style="color:#FF8833">ORANGE: ${scores.orange}</span>`;

        // Freeze car motion
        carBody.velocity.set(0, 0, 0);
        carBody.angularVelocity.set(0, 0, 0);
        if (botBody) {
            botBody.velocity.set(0, 0, 0);
            botBody.angularVelocity.set(0, 0, 0);
        }

        // ENTER REPLAY MODE
        ballMesh.visible = true;
        replayFrames = [...replayBuffer]; // COPY the last few seconds for playback
        replayIndex = 0;
        replayTimer = 5.1;
        gameState = 'replay';
    }

    
    // MODIFIED: updateAerialControls now prioritizes analog stick for pitch/yaw.
    function updateAerialControls() {
        if (hasDoubleJumped) return;

        const forwardVector = new CANNON.Vec3(0, 0, -1);
        const rightVector = new CANNON.Vec3(1, 0, 0);
        const upVector = new CANNON.Vec3(0, 1, 0);

        const rotatedForward = carBody.quaternion.vmult(forwardVector);
        const rotatedRight = carBody.quaternion.vmult(rightVector);
        const rotatedUp = carBody.quaternion.vmult(upVector);

        const AERIAL_ROTATION_RATE = 1.5;    
        const AIR_ROLL_MULTIPLIER = 2.0;    
        const MAX_AERIAL_ANGULAR_SPEED = 10.0;    

        function isSpeedCapped(axis, isPositiveDirection) {
            const currentSpeed = carBody.angularVelocity.dot(axis);
            if (isPositiveDirection) {
                return currentSpeed > MAX_AERIAL_ANGULAR_SPEED;
            } else {
                return currentSpeed < -MAX_AERIAL_ANGULAR_SPEED;
            }
        }
        
        // --- Pitch/Yaw Control (Gamepad/Analog Priority) ---
        if (gamepad || mobileControlsEnabled) { // Use analog if gamepad connected OR mobile controls enabled
            const pitch = inputs.driveAnalog; // Y-axis from stick
            const yaw = inputs.steerAnalog; // X-axis from stick
            
            if (Math.abs(pitch) > 0.1) {
                const pitchRate = pitch * AERIAL_ROTATION_RATE;
                // Apply rotation around the right axis. The inputs.driveAnalog is -1(up) to 1(down)
                if (pitch < 0 && !isSpeedCapped(rotatedRight, false)) { // Nose Up
                    carBody.angularVelocity.vsub(rotatedRight.scale(-pitchRate), carBody.angularVelocity);
                } else if (pitch > 0 && !isSpeedCapped(rotatedRight, true)) { // Nose Down
                    carBody.angularVelocity.vadd(rotatedRight.scale(pitchRate), carBody.angularVelocity);
                }
            }
            if (Math.abs(yaw) > 0.1) {
                const yawRate = yaw * AERIAL_ROTATION_RATE;
                // Apply rotation around the up axis (Yaw)
                if (yaw < 0 && !isSpeedCapped(rotatedUp, true)) { // Yaw Left
                    carBody.angularVelocity.vsub(rotatedUp.scale(yawRate), carBody.angularVelocity);
                } else if (yaw > 0 && !isSpeedCapped(rotatedUp, false)) { // Yaw Right
                    carBody.angularVelocity.vadd(rotatedUp.scale(yawRate), carBody.angularVelocity);
                }
            }
        } 
        // --- Pitch Control (KBM Fallback) ---
        if (!gamepad && !mobileControlsEnabled) {
            // Pitch Control (W/S) - Digital
            if (inputs.up && inputs.W_aerialReady && !isSpeedCapped(rotatedRight, false)) {
                carBody.angularVelocity.vsub(rotatedRight.scale(AERIAL_ROTATION_RATE), carBody.angularVelocity);    
            }
            if (inputs.down && inputs.S_aerialReady && !isSpeedCapped(rotatedRight, true)) {
                carBody.angularVelocity.vadd(rotatedRight.scale(AERIAL_ROTATION_RATE), carBody.angularVelocity);    
            }
        }


        // --- Roll Control (Q/E/Shoulder buttons) ---
        const rollRate = AERIAL_ROTATION_RATE * AIR_ROLL_MULTIPLIER;
        if (inputs.q && inputs.Q_aerialReady && !isSpeedCapped(rotatedForward, false)) {
            carBody.angularVelocity.vsub(rotatedForward.scale(rollRate), carBody.angularVelocity);
        }
        if (inputs.e && inputs.E_aerialReady && !isSpeedCapped(rotatedForward, true)) {
            carBody.angularVelocity.vadd(rotatedForward.scale(rollRate), carBody.angularVelocity);
        }

        // --- Yaw Control (A/D) - KBM Fallback Only ---
        if (!gamepad && !mobileControlsEnabled) {
            if (inputs.left && inputs.A_aerialReady && !isSpeedCapped(rotatedUp, true)) {
                carBody.angularVelocity.vsub(rotatedUp.scale(AERIAL_ROTATION_RATE), carBody.angularVelocity);
            }
            if (inputs.right && inputs.D_aerialReady && !isSpeedCapped(rotatedUp, false)) {
                carBody.angularVelocity.vadd(rotatedUp.scale(AERIAL_ROTATION_RATE), carBody.angularVelocity);
            }
        }

        // Apply air resistance to rotation
        carBody.angularVelocity.scale(0.99, carBody.angularVelocity);
    }

    function resetCameraInstant() {
        cameraYaw = 0;
        cameraYawDir.set(0, 0, -1);
    }

    // Global variable to help smooth camera movement
    let tempCarPos = new THREE.Vector3();
    let tempBallPos = new THREE.Vector3();

    function updateCamera(delta) {
        if (!carBody) return;

        let targetPos = new THREE.Vector3();
        let lookAtPos = new THREE.Vector3();
        
        // Smoothness factor (higher is smoother)
        const smoothFactor = 10 * delta; 
        
        // Lerp the physics position to a temp position to reduce stuttering caused by physics/render mismatch
        tempCarPos.lerp(carBody.position, smoothFactor);
        tempBallPos.lerp(ballBody.position, smoothFactor);

        if (gameState === 'replay') {
            // Look at the goal explosion point
            lookAtPos.copy(replayGoalPos);
            // Position camera behind the blue goal
            targetPos.set(0, GOAL_HEIGHT * 2, BLUE_GOAL_LINE - FIELD_L * 0.1); 
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(lookAtPos);
            return;
        }

        if (cameraMode === 'car') {
            const CAMERA_DISTANCE = 15 * SCALE_FACTOR;
            const CAMERA_HEIGHT = 5 * SCALE_FACTOR;
            const CAMERA_OFFSET_Z = 5 * SCALE_FACTOR; // Look slightly further ahead
            
            // Get car forward direction (CANNON.Vec3)
            const carForward = new CANNON.Vec3(0, 0, -1);
            carBody.quaternion.vmult(carForward, carForward);
            carForward.y = 0;
            carForward.normalize();
            
            // Convert CANNON.Vec3 to THREE.Vector3 for position calculation
            const threeCarForward = new THREE.Vector3(carForward.x, carForward.y, carForward.z);
            
            // 1. Calculate the target position: car position - (forward vector * distance) + (up vector * height)
            targetPos.copy(tempCarPos); 
            
            const cameraOffset = threeCarForward.clone().multiplyScalar(CAMERA_DISTANCE);
            targetPos.sub(cameraOffset);
            
            // 2. Set the height
            targetPos.y = tempCarPos.y + CAMERA_HEIGHT;
            
            // Smoothly move camera
            camera.position.lerp(targetPos, smoothFactor);
            
            // Look at point (slightly in front of the car)
            const lookAtOffset = threeCarForward.clone().multiplyScalar(CAMERA_OFFSET_Z);
            lookAtPos.copy(tempCarPos).add(lookAtOffset);
            
            camera.lookAt(lookAtPos);

        } else if (cameraMode === 'ball') {
            const BALL_CAM_DISTANCE = 35 * SCALE_FACTOR;
            const BALL_CAM_HEIGHT = 15 * SCALE_FACTOR;

            // Vector from car to ball
            const toBall = new THREE.Vector3().copy(tempBallPos).sub(tempCarPos);
            toBall.y = 0;
            toBall.normalize();

            // Target camera position (behind car, offset from the car-to-ball vector)
            targetPos.copy(tempCarPos);
            targetPos.sub(toBall.multiplyScalar(BALL_CAM_DISTANCE));
            targetPos.y = tempCarPos.y + BALL_CAM_HEIGHT;

            // Smoothly move camera
            camera.position.lerp(targetPos, smoothFactor);

            // Always look at the ball
            lookAtPos.copy(tempBallPos);
            camera.lookAt(lookAtPos);
        }
    }

    function updatePhysics() {
        // Determine Time Step (fixed 60 FPS)
        const fixedTimeStep = 1 / 60; 
        world.step(fixedTimeStep);

        // Update car mesh position
        carMesh.position.copy(carBody.position);
        carMesh.quaternion.copy(carBody.quaternion);

        // Update ball mesh position
        ballMesh.position.copy(ballBody.position);
        ballMesh.quaternion.copy(ballBody.quaternion);
        
        // Update bot mesh position
        if (botBody) {
            botMesh.position.copy(botBody.position);
            botMesh.quaternion.copy(botBody.quaternion);
        }
    }


    function updateBotAI() {
        if (!botBody || gameMode !== 'bot1v1') return;

        // Reset bot inputs
        botInputs.up = false;
        botInputs.down = false;
        botInputs.left = false;
        botInputs.right = false;
        botInputs.shift = false;

        // --- CONSTANTS & VECTORS ---
        
        // Orange Bot Goal Line (Z position the bot needs to defend, +Z side)
        const ORANGE_GOAL_LINE_Z = FIELD_L * 0.3; 
        // Blue Goal Line (Z position the bot needs to attack, -Z side)
        const BLUE_GOAL_LINE_Z = -FIELD_L * 0.3; 

        const BOT_Z = botBody.position.z;
        const BOT_X = botBody.position.x;

        // Vector from bot to ball (XZ plane only)
        const toBall = new CANNON.Vec3(
            ballBody.position.x - BOT_X,
            0,
            ballBody.position.z - BOT_Z
        );
        const toBallLength = toBall.length();

        // Get the bot's current forward direction (XZ plane only)
        const forward = botBody.quaternion.vmult(new CANNON.Vec3(0, 0, -1));
        forward.y = 0;
        forward.normalize();

        // Angle between forward direction and vector to ball (Angle of error)
        const angleToBall =
            Math.atan2(
                forward.x * toBall.z - forward.z * toBall.x,
                forward.x * toBall.x + forward.z * toBall.z
            );
            
        // --- 1. WALL AVOIDANCE (Unsticking) ---
        // Check if bot is past the opponent's goal line AND pushing into the wall
        const isStuckAtWall = (BOT_Z < BLUE_GOAL_LINE_Z - 5) && (forward.z < -0.5);

        if (isStuckAtWall) {
            // Reverse to unstick
            botInputs.down = true; 
            botInputs.left = false;
            botInputs.right = false;
            return; // Exit AI logic this frame to focus on unsticking
        }

        // --- 2. CORE CHASE LOGIC ---

        // The preferred position is behind the ball (closer to the bot's own goal, +Z side)
        const desiredZ = ballBody.position.z + 5; // Target slightly past the ball towards its goal
        
        // Check if the bot is on the wrong side of the ball (closer to the Blue goal/back of the ball)
        const isBehindBall = BOT_Z > ballBody.position.z; 

        if (isBehindBall) {
            // Attack Mode: Drive straight toward the ball
            
            // Steering: Adjust angle to point towards the ball
            if (angleToBall > 0.1) botInputs.left = true;
            else if (angleToBall < -0.1) botInputs.right = true;
            
            // Drive: Go forward
            botInputs.up = true;
            
        } else {
            // Positional Correction: Bot is too far forward (closer to the Blue goal than the ball)

            // Target: Move back to the desired Z-position behind the ball
            const toDesiredPos = new CANNON.Vec3(0, 0, desiredZ - BOT_Z); 
            
            // Calculate the angle to face the desired position 
            const angleToDesiredPos =
                Math.atan2(
                    forward.x * toDesiredPos.z - forward.z * toDesiredPos.x,
                    forward.x * toDesiredPos.x + forward.z * toDesiredPos.z
                );
                
            // Steering: Turn toward the desired Z position (away from the ball)
            if (angleToDesiredPos > 0.1) botInputs.left = true;
            else if (angleToDesiredPos < -0.1) botInputs.right = true;

            // Drive: Reverse to get behind the ball
            botInputs.down = true;
        }
        
        // --- 3. BOOST ---
        if (toBallLength > 60 && botInputs.up) { // Only boost if driving forward and far
            botInputs.shift = true;
        }
    }


    // Particle system for goal explosion
    let particleSystem;
    let particlesData = [];
    const particleCount = 100;
    const explosionDuration = 1.5;

    function createGoalExplosion(position, color) {
        // Remove old system if it exists
        if (particleSystem) {
            scene.remove(particleSystem);
            particleSystem.geometry.dispose();
            particleSystem.material.dispose();
        }

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        const colorObj = new THREE.Color(color);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            // Initial position is at the goal
            positions[i3 + 0] = position.x;
            positions[i3 + 1] = position.y;
            positions[i3 + 2] = position.z;

            colors[i3 + 0] = colorObj.r;
            colors[i3 + 1] = colorObj.g;
            colors[i3 + 2] = colorObj.b;

            // Random velocity vector (high impulse)
            const velX = (Math.random() - 0.5) * 60;
            const velY = Math.random() * 80 + 20; // Upwards bias
            const velZ = (Math.random() - 0.5) * 60;
            
            particlesData.push({
                velocity: new THREE.Vector3(velX, velY, velZ),
                startTime: performance.now() / 1000,
                originalPosition: new THREE.Vector3(position.x, position.y, position.z)
            });
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 5,
            transparent: true,
            opacity: 1.0,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthTest: true
        });

        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
    }

    function updateParticles() {
        if (!particleSystem) return;

        const currentTime = performance.now() / 1000;
        const positions = particleSystem.geometry.attributes.position.array;
        
        let activeParticles = 0;

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const data = particlesData[i];
            const timeElapsed = currentTime - data.startTime;

            if (timeElapsed < explosionDuration) {
                // Apply physics (basic gravity)
                const g = -150; // Gravity constant from CANNON.js
                
                // Calculate new position using kinematic equation: P = P0 + V0*t + 0.5*a*t^2
                positions[i3 + 0] = data.originalPosition.x + data.velocity.x * timeElapsed;
                positions[i3 + 1] = data.originalPosition.y + data.velocity.y * timeElapsed + 0.5 * g * timeElapsed * timeElapsed;
                positions[i3 + 2] = data.originalPosition.z + data.velocity.z * timeElapsed;

                // Fade out the particle
                particleSystem.material.opacity = 1.0 - (timeElapsed / explosionDuration);
                activeParticles++;
            } else {
                // Hide particle by moving it far away
                positions[i3 + 1] = -1000;
            }
        }
        
        particleSystem.geometry.attributes.position.needsUpdate = true;

        if (activeParticles === 0) {
            scene.remove(particleSystem);
            particleSystem = null;
        }
    }

    // Global clock for delta time calculation
    const clock = new THREE.Clock();

    // --- GAMEPAD FUNCTIONS (NEW) ---

    function setupGamepadListeners() {
        window.addEventListener('gamepadconnected', (e) => {
            // Only track the first connected gamepad for now
            if (!gamepad) {
                gamepad = e.gamepad;
                console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
                    gamepad.index, gamepad.id,
                    gamepad.buttons.length, gamepad.axes.length);
            }
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            if (gamepad && gamepad.index === e.gamepad.index) {
                gamepad = undefined;
                console.log("Gamepad disconnected from index %d: %s",
                    e.gamepad.index, e.gamepad.id);
                // Reset analog controls when gamepad disconnects
                inputs.driveAnalog = 0.0;
                inputs.steerAnalog = 0.0;
            }
        });
    }

    // Toggles digital/keyboard inputs
    let wasJumpPressed = false; 
    let wasCamPressed = false;

    function updateGamepad() {
        if (!gamepad) return;

        // Get fresh gamepad state (required for most browsers)
        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
        gamepad = gamepads[gamepad.index];

        if (!gamepad) return;

        // --- AXES (Analog Movement) ---
        const AXIS_THRESHOLD = 0.1;
        
        // Left Stick X (Steering): Axis 0
        const steer = gamepad.axes[0];
        inputs.steerAnalog = (Math.abs(steer) > AXIS_THRESHOLD) ? steer : 0.0;

        // Left Stick Y (Drive): Axis 1 (Inverted for forward/backward)
        const drive = gamepad.axes[1];
        // Invert Y-axis for standard controls: pushing UP (negative axis value) is FORWARD (positive driveAnalog)
        inputs.driveAnalog = (Math.abs(drive) > AXIS_THRESHOLD) ? -drive : 0.0; 

        // --- BUTTONS (Digital Actions) ---
        // Mapping is based on standard Xbox layout (A=0, B=1, X=2, Y=3, LB=4, RB=5, LT=6, RT=7)

        // 1. Jump/Flip (A/X - Button 0)
        const isJumpPressed = gamepad.buttons[0] ? gamepad.buttons[0].pressed : false;
        
        // Manual state handling to trigger the jump logic in the main loop (only on press down)
        if (isJumpPressed && !wasJumpPressed) {
            inputs.space = true;
        } else if (!isJumpPressed && wasJumpPressed) {
            inputs.space = false;
        }
        wasJumpPressed = isJumpPressed;

        // 2. Boost (RT/R2 - Button 7)
        inputs.shift = gamepad.buttons[7] ? gamepad.buttons[7].pressed : false;

        // 3. Air Roll Left (LB/L1 - Button 4)
        inputs.q = gamepad.buttons[4] ? gamepad.buttons[4].pressed : false;

        // 4. Air Roll Right (RB/R1 - Button 5)
        inputs.e = gamepad.buttons[5] ? gamepad.buttons[5].pressed : false;

        // 5. Camera Toggle (X/Square - Button 2)
        const isCamPressed = gamepad.buttons[2] ? gamepad.buttons[2].pressed : false;
        if (isCamPressed && !wasCamPressed) {
            // Trigger the camera toggle logic
            cameraMode = (cameraMode === 'car') ? 'ball' : 'car';
            document.getElementById('cameraMode').textContent = `Camera: ${cameraMode === 'car' ? 'Car Cam' : 'Ball Cam'}`;
        }
        wasCamPressed = isCamPressed;
        
        // 6. Pause (Start - Button 9)
        if (gamepad.buttons[9] && gamepad.buttons[9].pressed) {
            // Dispatch ESC key event to trigger the existing menu toggle logic
            const escEvent = new KeyboardEvent("keydown", { key: "Escape" });
            window.dispatchEvent(escEvent);
        }
    }


    function animate() {
        requestAnimationFrame(animate);
        if(!gameStarted) return;

        const delta = clock.getDelta();
        updateParticles(); // Update particles every frame
        updateGamepad();   // UPDATE GAMEPAD INPUTS

        if(gameState === 'replay') {
            if(replayIndex < replayFrames.length){
                const frame = replayFrames[replayIndex];
                
                // 1. Load Player Car (Index 0)
                carBody.position.copy(frame.cars[0].pos);
                carBody.quaternion.copy(frame.cars[0].quat);
                carMesh.position.copy(carBody.position); 
                carMesh.quaternion.copy(carBody.quaternion);
                
                // 2. Load Ball
                ballBody.position.copy(frame.ball.pos);
                ballBody.quaternion.copy(frame.ball.quat);
                ballMesh.position.copy(ballBody.position);
                ballMesh.quaternion.copy(ballBody.quaternion);
                
                // 3. Load Bot Car (Index 1)
                if (gameMode === 'bot1v1' && botBody && frame.cars.length > 1) {
                    botBody.position.copy(frame.cars[1].pos); // Bot is always index 1
                    botBody.quaternion.copy(frame.cars[1].quat);
                    botMesh.position.copy(botBody.position);
                    botMesh.quaternion.copy(botBody.quaternion);
                }
                
                replayIndex++;
                updateCamera(delta);
            } else {
                // End of replay, wait for timer
                replayTimer -= delta;
                updateCamera(delta);
                if (replayTimer <= 0) {
                    resetGame();
                }
            }
        } else {
            updatePhysics();
            checkGoal();
            recordReplayFrame();

            if (gameMode === 'bot1v1') {
                updateBotAI();
                applyCarControls(botBody, botInputs);
            }
            
            applyCarControls(carBody, inputs);

            const isCarOnGround = carBody.position.y < (CAR_SIZE.h * 1.5);
            if (!isCarOnGround && !isFlipping) {
                updateAerialControls();
            } else {
                // Apply damping after flip ends
                carBody.angularDamping = 0.9;
                hasDoubleJumped = false;
            }

            if (isFlipping) {
                flipTimer -= delta;
                if (flipTimer <= 0) {
                    isFlipping = false;
                }
            }
            
            updateCamera(delta);
        }

        renderer.render(scene, camera);
    }


    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }


    function recordReplayFrame() {
        if (gameState !== 'playing') return;

        // Save positions + rotations of ball and car(s)
        const frame = {
            ball: {
                pos: ballBody.position.clone(),
                quat: ballBody.quaternion.clone(),
            },
            cars: [
                {
                    pos: carBody.position.clone(),
                    quat: carBody.quaternion.clone(),
                }
            ]
        };
        
        if (gameMode === 'bot1v1' && botBody) {
            frame.cars.push({
                pos: botBody.position.clone(),
                quat: botBody.quaternion.clone(),
            });
        }

        replayBuffer.push(frame);

        // Keep buffer length fixed (only last REPLAY_LENGTH seconds)
        if (replayBuffer.length > REPLAY_LENGTH * REPLAY_FPS) {
            replayBuffer.shift();
        }
    }


    // --- MOBILE/JOYSTICK CONTROLS LOGIC (Retained from base file) ---

    function setupMobileControls() {
        const joystick = document.getElementById('joystick');
        const stick = document.getElementById('stick');
        const joystickRadius = 70; // Half of 140px width/height
        
        // Check if controls should be visible based on initial state (which is currently false, and toggled via settings)
        if (!mobileControlsEnabled) {
            joystick.style.display = 'none';
        } else {
            joystick.style.display = 'block';
        }
        
        let isDragging = false;
        let startX = 0;
        let startY = 0;
        let currentTouchId = null;

        function startDrag(e) {
            if (!mobileControlsEnabled) return;

            e.preventDefault();
            // Check if another touch is already dragging the joystick (multi-touch handling)
            if (isDragging) return; 

            isDragging = true;
            
            const touch = e.touches ? e.touches[0] : e;
            currentTouchId = e.touches ? touch.identifier : null;
            
            // Position the dynamic joystick where the touch occurred
            joystick.style.left = (touch.clientX - joystickRadius) + 'px';
            joystick.style.top = (touch.clientY - joystickRadius) + 'px';
            
            startX = touch.clientX;
            startY = touch.clientY;
        }

        function moveDrag(e) {
            if (!isDragging || !mobileControlsEnabled) return;
            e.preventDefault();
            
            let touch = e.touches ? Array.from(e.touches).find(t => t.identifier === currentTouchId) : e;
            if (!touch) touch = e; // Fallback for mouse/pointer

            let deltaX = touch.clientX - startX;
            let deltaY = touch.clientY - startY;
            
            let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX);

            // Cap distance to the joystick radius
            if (distance > joystickRadius) {
                distance = joystickRadius;
                deltaX = Math.cos(angle) * joystickRadius;
                deltaY = Math.sin(angle) * joystickRadius;
            }

            // Move the stick visual
            stick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

            // --- ANALOG INPUT MAPPING (UPDATED) ---
            // Y-axis for Drive: -1.0 (reverse) to 1.0 (forward)
            // Inverted: moving UP (negative Y delta) is forward (positive driveAnalog)
            inputs.driveAnalog = THREE.MathUtils.clamp(-deltaY / joystickRadius, -1, 1);
            
            // X-axis for Steer: -1.0 (left) to 1.0 (right)
            inputs.steerAnalog = THREE.MathUtils.clamp(deltaX / joystickRadius, -1, 1);
        }

        function endDrag(e) {
            if (!mobileControlsEnabled) return;
            // If using touch and the lifted touch is not the one controlling the stick, ignore
            if (e.changedTouches && isDragging && !Array.from(e.changedTouches).some(t => t.identifier === currentTouchId)) {
                return;
            }

            if (!isDragging) return;
            isDragging = false;
            currentTouchId = null;
            
            // Snap stick back to center and reset analog inputs
            stick.style.transform = `translate(0, 0)`;
            inputs.driveAnalog = 0.0;
            inputs.steerAnalog = 0.0;
            
            // Reset joystick position
            joystick.style.left = '20px';
            joystick.style.top = ''; 
            joystick.style.bottom = '20px'; 
        }

        // Add pointer/touch event listeners
        joystick.addEventListener('pointerdown', startDrag);
        document.addEventListener('pointermove', moveDrag);
        document.addEventListener('pointerup', endDrag);
        joystick.addEventListener('touchstart', startDrag);
        document.addEventListener('touchmove', moveDrag);
        joystick.addEventListener('touchend', endDrag);
    }


    const menuOverlay = document.getElementById('menuOverlay');
    const FreeBtn = document.getElementById('FreeplayBtn');
    const botBtn = document.getElementById('1v1Btn')
    const settingsBtn = document.getElementById('settingsBtn');
    const quitBtn = document.getElementById('quitBtn');


    FreeBtn.addEventListener('click', () => {
        menuOverlay.style.display = 'none';
        gameStarted = true;
        gameMode = 'freeplay';
        resetGame();
    });

    botBtn.addEventListener('click', () => {
        menuOverlay.style.display = 'none';
        gameStarted = true;
        gameMode = 'bot1v1';

        if (!botBody) createBotCar();
        resetGame();
    });


    settingsBtn.addEventListener('click', () => {
        const choice = confirm(
            "Mobile Controls are currently " + 
            (mobileControlsEnabled ? "ON" : "OFF") + 
            "\n\nPress OK to toggle."
        );

        if (choice) {
            mobileControlsEnabled = !mobileControlsEnabled;
            setupMobileControls(); // Re-run setup to show/hide the joystick
        }
    });


    quitBtn.addEventListener('click', () => {
        alert("Quitting game...");
        window.location.reload();
    });

    window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if(menuOverlay.style.display === 'flex'){
                menuOverlay.style.display = 'none';
                gameStarted = true;
            } else {
                menuOverlay.style.display = 'flex';
                gameStarted = false;
            }
        }
    });
</script>
</body>
</html>
