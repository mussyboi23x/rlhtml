<!DOCTYPE html>
<html>
<head>
    <title>Pocket League</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #info {
            position: absolute; top: 10px; width: 100%; text-align: center; color: white;
            pointer-events: none; text-shadow: 1px 1px 2px black; z-index: 10;
        }
        #score { font-size: 40px; font-weight: bold; }
        .controls { font-size: 14px; color: #ccc; margin-top: 5px; }
        #cameraMode { 
            font-size: 18px; 
            margin-top: 5px; 
            padding: 5px 10px; 
            background-color: rgba(0, 0, 0, 0.5); 
            border-radius: 5px;
            display: inline-block;
        }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; }
    </style>
	<style>
    /* Disable text selection everywhere */
    * {
        -webkit-user-select: none;   /* iPad / Safari */
        -webkit-touch-callout: none; /* Disable longâ€‘press menu */
        user-select: none;           /* Standard */
    }

    /* Remove Safari tap highlight */
    body {
        -webkit-tap-highlight-color: transparent;
    }

    /* Optional: stop scrolling / pinch zoom */
    html, body {
        touch-action: none;
    }


#joystick {
    position: fixed;
    width: 140px;
    height: 140px;
    background: rgba(255,255,255,0.1);
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 50%;
    pointer-events: none;
    touch-action: none;
}

#stick {
    position: absolute;
    width: 60px;
    height: 60px;
    background: rgba(255,255,255,0.3);
    border-radius: 50%;
    left: 40px;
    top: 40px;
    transform: translate(0, 0);
    pointer-events: none;
}

#pauseBtn {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 50px;
    height: 50px;
    background: rgba(255,255,255,0.15);
    border: 2px solid rgba(255,255,255,0.25);
    border-radius: 8px;
    color: white;
    font-size: 28px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    touch-action: none;
}

	
</style>

</head>
<body>

<div id="pauseBtn">II</div>


<div id="joystick" style="display:none;">
    <div id="stick"></div>
</div>

<div id="menuOverlay">
    <div id="menuBox">
        <h1>Pocket League</h1>
        <button id="FreeplayBtn">Freeplay</button>
	<button id="1v1Btn">Bot 1v1</button>
        <button id="settingsBtn">Settings</button>
        <button id="quitBtn">Quit</button>
    </div>
</div>

<style>
#menuOverlay {
    position: absolute;
    top:0; left:0;
    width:100%; height:100%;
    background: rgba(0,0,0,0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 20;
}
#menuBox {
    background: #111122;
    padding: 30px 50px;
    border-radius: 12px;
    text-align: center;
    color: #fff;
    box-shadow: 0 0 20px #000;
}
#menuBox h1 {
    margin-bottom: 20px;
    font-size: 36px;
    color: #4488FF;
}
#menuBox button {
    display: block;
    width: 200px;
    margin: 10px auto;
    padding: 10px;
    font-size: 18px;
    border: none;
    border-radius: 6px;
    background: #4488FF;
    color: #fff;
    cursor: pointer;
    transition: all 0.2s;
}
#menuBox button:hover {
    background: #66aaff;
    transform: scale(1.05);
}
</style>


<div id="info">
    <div id="score"><span style="color:#4488FF">BLUE: 0</span> - <span style="color:#FF8833">ORANGE: 0</span></div>
    <div class="controls">WASD / ARROWS to Drive | <b>Q/E</b> for Air Roll | <b>SPACE (x2)</b> to Jump/Flip | <b>SHIFT</b> to Boost | <b>ENTER</b> to Switch Camera | R to Reset</div>
    <div id="cameraMode">Camera: Car Cam</div>
</div>
<div id="loading">Loading Engine...</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

<script>
    // --- CONFIGURATION ---
    const SCALE_FACTOR = 4;
    const FIELD_W = 60 * SCALE_FACTOR;    
    const FIELD_L = 100 * SCALE_FACTOR;  
    const ARENA_HEIGHT = 80;    
    const GOAL_WIDTH = 50;    
    const GOAL_DEPTH = 10;
    const GOAL_HEIGHT = 25;
    const CAR_SIZE = { w: 2, h: 1, l: 4 };
    const BALL_RADIUS = 5;    
    
    // NEW CONSTANT FOR WALLS
    const WALL_THICKNESS = 5;    
    
    // Derived Constants
    const BACKBOARD_HEIGHT = GOAL_HEIGHT * 2.5;    
    const END_WALL_LENGTH = (FIELD_W - GOAL_WIDTH) / 2;
    
    // --- GLOBALS ---
    let flipTimer = 0;
    let isFlipping = false;
    let scene, camera, renderer;
    let world, physicsMaterials = {};
    let carBody, carMesh, ballBody, ballMesh;
    let cameraYaw = 0;
    let flipAxis = new CANNON.Vec3();
    let cameraYawDir = new THREE.Vector3(0, 0, -1);
    let replayTimer = 0;
    let replayGoalPos = new THREE.Vector3();
    let replayBuffer = [];    // stores recorded frames
    let replayIndex = 0;      // current frame for replay
    let isRecordingReplay = false;
    let isReplaying = false;
    let REPLAY_LENGTH = 5; // seconds to replay
    let REPLAY_FPS = 60;    // how many frames per second
    let gameStarted = false;
    let botBody, botMesh;
    let gameMode = 'freeplay';
	let mobileControlsEnabled = false;
let botInputs = {
    up: false,
    down: false,
    left: false,
    right: false,
    shift: false
};

// TWEAK 1: Update inputs to include analog values
let inputs = { 
    // KBM Digital Inputs (set by keyboard handler)
    up: false, down: false, left: false, right: false, space: false, shift: false,
    q: false, e: false, enter: false,
    
    // Analog Inputs (set by joystick handler, 0.0 to 1.0 or -1.0 to 1.0)
    driveAnalog: 0.0, // -1.0 (reverse) to 1.0 (forward)
    steerAnalog: 0.0, // -1.0 (left) to 1.0 (right)
    
    // Aerial flags
    W_aerialReady: false, S_aerialReady: false, A_aerialReady: false,
    D_aerialReady: false, Q_aerialReady: false, E_aerialReady: false  
};
    
    let scores = { blue: 0, orange: 0 };
    let gameState = 'playing';

    let cameraMode = 'car'; // 'car' or 'ball'

    // --- AIRDODGE GLOBALS ---
    let lastJumpTime = 0;
    const DOUBLE_JUMP_LOCKOUT = 1.25;    
    let hasDoubleJumped = false;
    const FLIP_IMPULSE = 35 * SCALE_FACTOR;
    const FORWARD_FLIP_IMPULSE = 45 * SCALE_FACTOR;    
    const FLIP_ROTATION = 1.0;    
    
    // MOVEMENT CONSTANTS
    const BASE_SPEED = 20 * SCALE_FACTOR;
    const BOOST_SPEED = 20 * SCALE_FACTOR;    
    const TURN_RATE = 0.032;    
    const JUMP_VELOCITY = 30 * Math.sqrt(SCALE_FACTOR);    
    const BOOST_VELOCITY_ADD = 1 * SCALE_FACTOR;    
    
    const BLUE_GOAL_LINE = -FIELD_L/2;
    const ORANGE_GOAL_LINE = FIELD_L/2;

    init();
    animate();

    function init() {
        // 1. SETUP THREE.JS
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0A0A1F);    
        scene.fog = new THREE.Fog(0x0A0A1F, FIELD_L * 0.4, FIELD_L * 1.5);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // LIGHTING
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x112211, 1.0);    
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -FIELD_W / 2;
        dirLight.shadow.camera.right = FIELD_W / 2;
        dirLight.shadow.camera.top = FIELD_L / 2;
        dirLight.shadow.camera.bottom = -FIELD_L / 2;
        scene.add(dirLight);

        // 2. SETUP CANNON.JS PHYSICS
        world = new CANNON.World();
        world.gravity.set(0, -150, 0);    
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Materials
        const groundMat = new CANNON.Material();
        const objMat = new CANNON.Material();
        
        // --- ZERO GROUND FRICTION ---
        const objContactMat = new CANNON.ContactMaterial(groundMat, objMat, { friction: 0.0, restitution: 0.5 });    
        const ballContactMat = new CANNON.ContactMaterial(objMat, objMat, { friction: 0.0, restitution: 0.55 });    

        world.addContactMaterial(objContactMat);
        world.addContactMaterial(ballContactMat);

        physicsMaterials = { ground: groundMat, object: objMat };

        // 3. BUILD WORLD
        createField();
        createCeiling();    
        createCar();    
        createBall();
        createScenery();    

        // 4. EVENTS
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', (e) => handleKey(e, true));
        window.addEventListener('keyup', (e) => handleKey(e, false));
        
        // TWEAK 4: Setup mobile controls
        setupMobileControls();
        
        document.getElementById('loading').style.display = 'none';
    }

    // Helper function for static boundaries (used for walls and backboards)
    function createBoundary(x, y, z, w, h, d, color = 0xAAAAAA, opacity = 0.1, visible = true) {
        const shape = new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2));
        const body = new CANNON.Body({ mass: 0, material: physicsMaterials.object });
        body.addShape(shape);
        // Position Y is y + h/2 (where y is the ground level 0)
        body.position.set(x, y + h/2, z);
        world.addBody(body);
        
        const geo = new THREE.BoxGeometry(w, h, d);
        let mat;
        if (visible) {
            mat = new THREE.MeshStandardMaterial({ color: color, transparent: true, opacity: opacity, side: THREE.DoubleSide });
        } else {
            mat = new THREE.MeshBasicMaterial({ visible: false });
        }
        
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(body.position);
        mesh.receiveShadow = visible;
        scene.add(mesh);
    }

    function createScenery() {
        const sceneryHeight = ARENA_HEIGHT * 4;    
        const sceneryGroundColor = 0x113309;    
        const sceneryTreeColor = 0x114411;    
        const offset = 100;    
        const totalLength = FIELD_L * 2;
        const totalWidth = FIELD_W * 2;

        const outerGroundGeo = new THREE.PlaneGeometry(FIELD_W * 5, FIELD_L * 5);
        const outerGroundMat = new THREE.MeshStandardMaterial({ color: sceneryGroundColor, roughness: 0.8, side: THREE.DoubleSide });
        const outerGround = new THREE.Mesh(outerGroundGeo, outerGroundMat);
        outerGround.rotation.x = -Math.PI / 2;
        outerGround.position.y = -5;    
        outerGround.receiveShadow = true;
        scene.add(outerGround);

        const treeDensity = 20;    
        const treeRadius = 5;
        const treeGeo = new THREE.CylinderGeometry(treeRadius, treeRadius, sceneryHeight, 8);
        const treeMat = new THREE.MeshStandardMaterial({ color: sceneryTreeColor });

        for (let i = 0; i < treeDensity; i++) {
            const z = -totalLength / 2 + i * (totalLength / (treeDensity - 1));
            const meshL = new THREE.Mesh(treeGeo, treeMat);
            meshL.position.set(-FIELD_W / 2 - offset, sceneryHeight / 2, z);
            scene.add(meshL);
            const meshR = new THREE.Mesh(treeGeo, treeMat);
            meshR.position.set(FIELD_W / 2 + offset, sceneryHeight / 2, z);
            scene.add(meshR);
        }

        for (let i = 0; i < treeDensity; i++) {
            const x = -totalWidth / 2 + i * (totalWidth / (treeDensity - 1));
            const meshB = new THREE.Mesh(treeGeo, treeMat);
            meshB.position.set(x, sceneryHeight / 2, -FIELD_L / 2 - offset);
            scene.add(meshB);
            const meshO = new THREE.Mesh(treeGeo, treeMat);
            meshO.position.set(x, sceneryHeight / 2, FIELD_L / 2 + offset);
            scene.add(meshO);
        }
    }

    // Goal Net Visual (NOT the solid backboard)
    function createGoal(isBlue) {
        const GOAL_Z_START = isBlue ? BLUE_GOAL_LINE : ORANGE_GOAL_LINE;
        
        const netZ = GOAL_Z_START + (isBlue ? -GOAL_DEPTH/2 : GOAL_DEPTH/2);
        const geo = new THREE.BoxGeometry(GOAL_WIDTH, GOAL_HEIGHT, GOAL_DEPTH);
        const color = isBlue ? 0x0044FF : 0xFF8800;
        const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5, transparent: true, opacity: 0.3 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(0, GOAL_HEIGHT/2, netZ);
        scene.add(mesh);
    }

    function createCeiling() {
        const CEILING_X_VISUAL = FIELD_W + WALL_THICKNESS * 2;    
        // Calculate the required Z length based on the new wall positions
        const CEILING_Z_VISUAL = FIELD_L + GOAL_DEPTH * 2 + WALL_THICKNESS;    

        const ceilingGeo = new THREE.PlaneGeometry(CEILING_X_VISUAL, CEILING_Z_VISUAL);
        const ceilingMat = new THREE.MeshBasicMaterial({ color: 0x444488, transparent: true, opacity: 0.1, side: THREE.DoubleSide });
        const ceilingMesh = new THREE.Mesh(ceilingGeo, ceilingMat);
        ceilingMesh.rotation.x = Math.PI / 2;
        ceilingMesh.position.y = ARENA_HEIGHT;
        scene.add(ceilingMesh);

        const ceilingShape = new CANNON.Plane();
        const ceilingBody = new CANNON.Body({ mass: 0, material: physicsMaterials.object });
        ceilingBody.addShape(ceilingShape);
        
        ceilingBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
        ceilingBody.position.y = ARENA_HEIGHT;
        world.addBody(ceilingBody);
    }


    function createField() {
        // 1. GROUND PLANE
        const geometry = new THREE.PlaneGeometry(FIELD_W, FIELD_L);
        const material = new THREE.MeshStandardMaterial({ color: 0x103309, roughness: 0.8, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(geometry, material);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: physicsMaterials.ground });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(groundBody);
        
        // --- 2. STRAIGHT VERTICAL WALLS ---
        
        const WALL_HEIGHT = ARENA_HEIGHT;
        const HALF_WALL_THICKNESS = WALL_THICKNESS / 2;
        const HALF_FIELD_W = FIELD_W / 2;
        const HALF_GOAL_WIDTH = GOAL_WIDTH / 2;

        // A. SIDE WALLS (+X and -X)
        // Total side wall length must cover the FIELD_L plus the two goal enclosures and the wall thickness at the ends.
        const TOTAL_SIDE_WALL_LENGTH = FIELD_L + GOAL_DEPTH * 2 + WALL_THICKNESS;    
        
        // Right Side (+X) - centered at Z=0
        createBoundary(HALF_FIELD_W + HALF_WALL_THICKNESS, 0, 0, WALL_THICKNESS, WALL_HEIGHT, TOTAL_SIDE_WALL_LENGTH, 0xAAAAAA, 0.2, true);    
        // Left Side (-X) - centered at Z=0
        createBoundary(-HALF_FIELD_W - HALF_WALL_THICKNESS, 0, 0, WALL_THICKNESS, WALL_HEIGHT, TOTAL_SIDE_WALL_LENGTH, 0xAAAAAA, 0.2, true);    

        // B. END WALLS & BACKBOARDS (+Z and -Z)
        
        // Z-positions for all end walls (centered)
        const ORANGE_END_Z_CENTER = ORANGE_GOAL_LINE + GOAL_DEPTH + HALF_WALL_THICKNESS;    
        const BLUE_END_Z_CENTER = BLUE_GOAL_LINE - GOAL_DEPTH - HALF_WALL_THICKNESS;
        
        // Calculations for the split end walls (the non-goal sections)
        const W_split = (FIELD_W - GOAL_WIDTH) / 2;
        // The width of the split wall piece, extended to meet the side wall by WALL_THICKNESS
        const W_split_final = W_split + WALL_THICKNESS;    
        
        // Center X for the split walls, which is halfway between the goal edge (GOAL_WIDTH/2) and the outer arena edge (FIELD_W/2 + WALL_THICKNESS/2)
        const baseSplitCenter = HALF_GOAL_WIDTH + W_split / 2;
        
        const rightSplitXCenter = baseSplitCenter + HALF_WALL_THICKNESS / 2;
        const leftSplitXCenter = -baseSplitCenter - HALF_WALL_THICKNESS / 2;
        
        // --- ORANGE END (+Z) WALLS ---
        const orangeBackboardColor = 0xFF8800;
        
        // Backboard (Goal Area) - Width: GOAL_WIDTH, Centered at X=0
        createBoundary(0, 0, ORANGE_END_Z_CENTER, GOAL_WIDTH, WALL_HEIGHT, WALL_THICKNESS, orangeBackboardColor, 0.5, true);    
        
        // Right Side Wall Piece (Beside Goal)    
        createBoundary(rightSplitXCenter, 0, ORANGE_END_Z_CENTER, W_split_final, WALL_HEIGHT, WALL_THICKNESS, 0xAAAAAA, 0.2, true);
        
        // Left Side Wall Piece (Beside Goal)    
        createBoundary(leftSplitXCenter, 0, ORANGE_END_Z_CENTER, W_split_final, WALL_HEIGHT, WALL_THICKNESS, 0xAAAAAA, 0.2, true);

        
        // --- BLUE END (-Z) WALLS ---
        const blueBackboardColor = 0x0044FF;

        // Backboard (Goal Area) - Width: GOAL_WIDTH, Centered at X=0
        createBoundary(0, 0, BLUE_END_Z_CENTER, GOAL_WIDTH, WALL_HEIGHT, WALL_THICKNESS, blueBackboardColor, 0.5, true);    

        // Right Side Wall Piece (Beside Goal)
        createBoundary(rightSplitXCenter, 0, BLUE_END_Z_CENTER, W_split_final, WALL_HEIGHT, WALL_THICKNESS, 0xAAAAAA, 0.2, true);
        
        // Left Side Wall Piece (Beside Goal)
        createBoundary(leftSplitXCenter, 0, BLUE_END_Z_CENTER, W_split_final, WALL_HEIGHT, WALL_THICKNESS, 0xAAAAAA, 0.2, true);
        
        // 3. Goal Net Visuals
        createGoal(true);
        createGoal(false);
    }

    function createCar() {
        const shape = new CANNON.Box(new CANNON.Vec3(CAR_SIZE.w, CAR_SIZE.h, CAR_SIZE.l));
        carBody = new CANNON.Body({ mass: 150 * SCALE_FACTOR, material: physicsMaterials.object });    
        carBody.addShape(shape);
        // TWEAK 2: Correct Player Car (Blue) spawn to -Z side
        carBody.position.set(0, 2, -FIELD_L * 0.3);
        carBody.linearDamping = 0.01;    
        carBody.angularDamping = 0.9;
        world.addBody(carBody);

        carMesh = new THREE.Group();
        
        const bodyGeo = new THREE.BoxGeometry(CAR_SIZE.w * 2, CAR_SIZE.h * 2, CAR_SIZE.l * 2);
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x3388FF });
        const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
        bodyMesh.castShadow = true;
        carMesh.add(bodyMesh);

        const roofGeo = new THREE.BoxGeometry(3.5, 0.5, 2);
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.position.y = 1;
        roof.position.z = -1;
        carMesh.add(roof);

        const wheelGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 12);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const positions = [[-2, -1, 2], [2, -1, 2], [-2, -1, -2], [2, -1, -2]];
        positions.forEach(pos => {
            const w = new THREE.Mesh(wheelGeo, wheelMat);
            w.rotation.z = Math.PI / 2;
            w.position.set(...pos);
            carMesh.add(w);
        });
        
        scene.add(carMesh);
    }

function createBotCar() {
    const shape = new CANNON.Box(
        new CANNON.Vec3(CAR_SIZE.w, CAR_SIZE.h, CAR_SIZE.l)
    );

    botBody = new CANNON.Body({
        mass: 150 * SCALE_FACTOR,
        material: physicsMaterials.object
    });

    botBody.addShape(shape);
    // TWEAK 2: Correct Bot Car (Orange) spawn to +Z side
    botBody.position.set(0, 2, FIELD_L * 0.3);
    botBody.linearDamping = 0.01;
    botBody.angularDamping = 0.9;
    world.addBody(botBody);

    // MESH SETUP (Added roof and wheels for visibility)
    botMesh = new THREE.Group();

    const bodyGeo = new THREE.BoxGeometry(
        CAR_SIZE.w * 2,
        CAR_SIZE.h * 2,
        CAR_SIZE.l * 2
    );
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xFF8833 }); // Orange color
    const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
    bodyMesh.castShadow = true;
    botMesh.add(bodyMesh);
    
    // Add Roof
    const roofGeo = new THREE.BoxGeometry(3.5, 0.5, 2);
    const roofMat = new THREE.MeshStandardMaterial({ color: 0x222222 });    
    const roof = new THREE.Mesh(roofGeo, roofMat);
    roof.position.y = 1;
    roof.position.z = -1;
    botMesh.add(roof);

    // Add Wheels
    const wheelGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 12);
    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
    const positions = [[-2, -1, 2], [2, -1, 2], [-2, -1, -2], [2, -1, -2]];
    positions.forEach(pos => {
        const w = new THREE.Mesh(wheelGeo, wheelMat);
        w.rotation.z = Math.PI / 2;
        w.position.set(...pos);
        botMesh.add(w);
    });

    scene.add(botMesh);
}

// TWEAK 3: Update controls to use analog input
function applyCarControls(body, controlInputs) {
    const isCarOnGround = body.position.y < (CAR_SIZE.h * 1.5);
    const forwardVector = new CANNON.Vec3(0, 0, -1);
    const rotatedForward = body.quaternion.vmult(forwardVector);

    // --- 1. Calculate Combined Drive Factor (Analog Priority) ---
    let driveFactor = 0; // -1.0 (reverse) to 1.0 (forward)
    
    if (Math.abs(controlInputs.driveAnalog) > 0.05) {
        driveFactor = controlInputs.driveAnalog; // Use analog value
        // The joystick gives -1.0 to 1.0, so use the raw value
        if (driveFactor < 0) {
            driveFactor *= 0.5; // Half speed for reverse (matching KBM down)
        }
    } else if (controlInputs.up) {
        driveFactor = 1.0; // Digital forward
    } else if (controlInputs.down) {
        driveFactor = -0.5; // Digital reverse (half speed)
    }
    
    // Apply speed based on the combined drive factor
    const targetSpeed = BASE_SPEED * driveFactor; 

    const targetVelocity = rotatedForward.scale(targetSpeed);
    const accelFactor = 0.05;

    // Smoothly apply acceleration
    body.velocity.x = body.velocity.x * (1 - accelFactor) + targetVelocity.x * accelFactor;
    body.velocity.z = body.velocity.z * (1 - accelFactor) + targetVelocity.z * accelFactor;

    // 2. Boost as Velocity Addition
    if (controlInputs.shift) {
        const boostImpulse = rotatedForward.scale(BOOST_VELOCITY_ADD);
        body.velocity.vadd(boostImpulse, body.velocity);
    }
    
    // 3. Ground Steering (Yaw rotation)
    if (isCarOnGround) {
        // --- Calculate Combined Steer Factor (Analog Priority) ---
        let steerFactor = 0; // -1.0 (left) to 1.0 (right)
        
        if (Math.abs(controlInputs.steerAnalog) > 0.05) {
            steerFactor = controlInputs.steerAnalog; // Use analog value
        } else {
            steerFactor = (controlInputs.left ? 1 : 0) - (controlInputs.right ? 1 : 0); // Digital value
        }

        if (steerFactor !== 0) {
            const speed = Math.sqrt(
                body.velocity.x ** 2 +
                body.velocity.z ** 2
            );

            if (speed > 0.2) {
                // Apply the analog/digital factor to the steering strength
                const turnStrength = steerFactor * TURN_RATE * (speed / BASE_SPEED);

                const rot = new CANNON.Quaternion();
                rot.setFromAxisAngle(
                    new CANNON.Vec3(0, 1, 0),
                    turnStrength
                );

                body.quaternion = rot.mult(body.quaternion);
            }
        }

        // 4. Ground Grip (Dampens side slide)
        const rightVector = body.quaternion.vmult(new CANNON.Vec3(1, 0, 0));
        const sideSpeed = body.velocity.dot(rightVector);
        const SIDE_GRIP = 0.8; 
        body.velocity.vsub(
            rightVector.scale(sideSpeed * SIDE_GRIP),
            body.velocity
        );
    }
}

    function createBall() {
        const shape = new CANNON.Sphere(BALL_RADIUS);
        ballBody = new CANNON.Body({ mass: 10 * SCALE_FACTOR, material: physicsMaterials.object });
        ballBody.addShape(shape);
        ballBody.position.set(0, BALL_RADIUS * 2, 0);    
        ballBody.linearDamping = 0.1;
        ballBody.angularDamping = 0.1;
        world.addBody(ballBody);

        const geo = new THREE.SphereGeometry(BALL_RADIUS, 16, 16);
        const mat = new THREE.MeshStandardMaterial({ color: 0xEEEEEE, roughness: 0.2, metalness: 0.1 });
        ballMesh = new THREE.Mesh(geo, mat);
        ballMesh.castShadow = true;
        scene.add(ballMesh);

        const light = new THREE.PointLight(0xffffff, 0.5, 20);
        ballMesh.add(light);
    }

    function airDodge() {
    const currentTime = performance.now() / 1000;
    if (currentTime - lastJumpTime > DOUBLE_JUMP_LOCKOUT || hasDoubleJumped) return;

    hasDoubleJumped = true;
    isFlipping = true;
    flipTimer = 0.4; // seconds (Rocket League-like)

    carBody.angularDamping = 0.05;

    const forward = new CANNON.Vec3(0, 0, -1);
    const right = new CANNON.Vec3(-1, 0, 0);
    const left = new CANNON.Vec3(1, 0, 0);
    const down = new CANNON.Vec3(0, 0, 1);

    const f = carBody.quaternion.vmult(forward);
    const r = carBody.quaternion.vmult(right);
    const l = carBody.quaternion.vmult(left);
    const d = carBody.quaternion.vmult(down);

    flipAxis.set(0, 0, 0);

if (inputs.up) {                 // front flip
    flipAxis.copy(r); // FLIPPED
    carBody.velocity.vadd(f.scale(-18), carBody.velocity);
} else if (inputs.down) {          // back flip
    flipAxis.copy(l).scale(-1); // FLIPPED
    carBody.velocity.vadd(f.scale(14), carBody.velocity);
} else if (inputs.right) {         // right flip
    flipAxis.copy(f); // FLIPPED
    carBody.velocity.vadd(r.scale(14), carBody.velocity);
} else if (inputs.left) {          // left flip
    flipAxis.copy(d); // FLIPPED
    carBody.velocity.vadd(r.scale(-14), carBody.velocity);

    } else {
        carBody.velocity.y += JUMP_VELOCITY * 0.5;
        isFlipping = false;
        return;
    }

    carBody.angularVelocity.set(
        flipAxis.x * 12,
        flipAxis.y * 12,
        flipAxis.z * 12
    );
}

    
    function handleKey(e, isDown) {
        const wasSpaceDown = inputs.space;
        const key = e.key.toLowerCase();
        const isCarAirborne = carBody.position.y >= (CAR_SIZE.h * 1.5);
        
        function updateAerialReady(keyName, keyState) {
            const flagName = `${keyName}_aerialReady`;
            if (keyState && isCarAirborne) {
                inputs[flagName] = true;
            } else if (!keyState) {
                inputs[flagName] = false;
            }
        }

        switch(key) {
            case 'w': case 'arrowup':    
                inputs.up = isDown;    
                updateAerialReady('W', isDown);
                break;
            case 's': case 'arrowdown':    
                inputs.down = isDown;    
                updateAerialReady('S', isDown);
                break;
            case 'a': case 'arrowleft':    
                inputs.left = isDown;    
                updateAerialReady('A', isDown);
                break;
            case 'd': case 'arrowright':    
                inputs.right = isDown;    
                updateAerialReady('D', isDown);
                break;
            case 'q':    
                inputs.q = isDown;    
                updateAerialReady('Q', isDown);
                break;
            case 'e':    
                inputs.e = isDown;    
                updateAerialReady('E', isDown);
                break;
            case ' ': inputs.space = isDown; break;
            case 'shift': inputs.shift = isDown; break;
            case 'enter':    
                if (isDown) {
                    cameraMode = (cameraMode === 'car') ? 'ball' : 'car';
                    document.getElementById('cameraMode').textContent = `Camera: ${cameraMode === 'car' ? 'Car Cam' : 'Ball Cam'}`;
                }
                break;
            case 'r': if(isDown) resetGame(); break;
        }

        const isCarOnGround = carBody.position.y < (CAR_SIZE.h * 1.5);
        const currentTime = performance.now() / 1000;
        
        if (inputs.space && !wasSpaceDown && isCarOnGround) {    
            carBody.velocity.y = JUMP_VELOCITY;
            lastJumpTime = currentTime;
            
            inputs.W_aerialReady = inputs.up ? false : inputs.W_aerialReady;
            inputs.S_aerialReady = inputs.down ? false : inputs.S_aerialReady;
            inputs.A_aerialReady = inputs.left ? false : inputs.A_aerialReady;
            inputs.D_aerialReady = inputs.up ? false : inputs.D_aerialReady;
            inputs.Q_aerialReady = inputs.q ? false : inputs.Q_aerialReady;
            inputs.E_aerialReady = inputs.e ? false : inputs.E_aerialReady;
        }

        if (inputs.space && !wasSpaceDown) {
             if (!isCarOnGround && currentTime - lastJumpTime < DOUBLE_JUMP_LOCKOUT && !hasDoubleJumped) {
                 airDodge();
             }
        }
    }

    function resetGame() {
        // TWEAK 2: Correct Player Car (Blue) spawn to -Z side
        carBody.position.set(0, 2, -FIELD_L * 0.3);
        carBody.velocity.set(0, 0, 0);
        carBody.quaternion.set(0, 0, 0, 1);
        carBody.angularVelocity.set(0, 0, 0);

        ballMesh.visible = true;
        ballBody.collisionFilterGroup = 1; // re-enable collisions


        ballBody.position.set(0, BALL_RADIUS * 2, 0);    
        ballBody.velocity.set(0, 0, 0);
        ballBody.angularVelocity.set(0, 0, 0);

        if (botBody) {
             // TWEAK 2: Correct Bot Car (Orange) spawn to +Z side
             botBody.position.set(0, 2, FIELD_L * 0.3);
             botBody.velocity.set(0, 0, 0);
             botBody.quaternion.set(0, 0, 0, 1);
             botBody.angularVelocity.set(0, 0, 0);
        }
        
       isFlipping = false;
       flipTimer = 0;
       flipAxis.set(0, 0, 0);
       carBody.angularDamping = 0.9;

	resetCameraInstant();

        lastJumpTime = 0;
        hasDoubleJumped = false;
        
        // Reset analog inputs on game reset
        inputs.driveAnalog = 0.0;
        inputs.steerAnalog = 0.0;
        
        gameState = 'playing';
        
        inputs.W_aerialReady = false;
        inputs.S_aerialReady = false;
        inputs.A_aerialReady = false;
        inputs.D_aerialReady = false;
        inputs.Q_aerialReady = false;
        inputs.E_aerialReady = false;
    }

    function checkGoal() {
        if (gameState !== 'playing') return;

        const ballX = ballBody.position.x;
        const ballZ = ballBody.position.z;
        const ballY = ballBody.position.y;
        const goalRange = GOAL_WIDTH / 2;    

        // The check still uses the original GOAL_LINE positions, defining the scoring zone.
        if (ballZ < BLUE_GOAL_LINE && Math.abs(ballX) < goalRange && ballY < GOAL_HEIGHT) {
            score('orange');
        }    
        else if (ballZ > ORANGE_GOAL_LINE && Math.abs(ballX) < goalRange && ballY < GOAL_HEIGHT) {
            score('blue');
        }
    }

function score(team) {
    const goalZ = team === 'blue' ? ORANGE_GOAL_LINE : BLUE_GOAL_LINE;
    const goalColor = team === 'blue' ? 0x4488FF : 0xFF8833;

    // Spawn goal explosion
    createGoalExplosion(new THREE.Vector3(0, GOAL_HEIGHT / 2, goalZ), goalColor);

    // Hide ball & disable collisions
    ballMesh.visible = false;
    ballBody.collisionFilterGroup = 0;

    // Record goal position for replay
    replayGoalPos.set(0, GOAL_HEIGHT / 2, goalZ);

    // Update scores
    scores[team]++;
    document.getElementById('score').innerHTML =
        `<span style="color:#4488FF">BLUE: ${scores.blue}</span> - <span style="color:#FF8833">ORANGE: ${scores.orange}</span>`;

    // Freeze car motion
    carBody.velocity.set(0, 0, 0);
    carBody.angularVelocity.set(0, 0, 0);

    // ENTER REPLAY MODE
    ballMesh.visible = true;
    replayFrames = [...replayBuffer]; // last few seconds
    replayIndex = 0;
    replayTimer = 5.1;
    gameState = 'replay';
}

    
    function updateAerialControls() {
        if (hasDoubleJumped) return;

        const forwardVector = new CANNON.Vec3(0, 0, -1);
        const rightVector = new CANNON.Vec3(1, 0, 0);
        const upVector = new CANNON.Vec3(0, 1, 0);

        const rotatedForward = carBody.quaternion.vmult(forwardVector);
        const rotatedRight = carBody.quaternion.vmult(rightVector);
        const rotatedUp = carBody.quaternion.vmult(upVector);

        const AERIAL_ROTATION_RATE = 1.5;    
        const AIR_ROLL_MULTIPLIER = 2.0;    
        const MAX_AERIAL_ANGULAR_SPEED = 10.0;    

        function isSpeedCapped(axis, isPositiveDirection) {
            const currentSpeed = carBody.angularVelocity.dot(axis);
            if (isPositiveDirection) {
                return currentSpeed > MAX_AERIAL_ANGULAR_SPEED;
            } else {
                return currentSpeed < -MAX_AERIAL_ANGULAR_SPEED;
            }
        }
        
        // Pitch Control (W/S)
        if (inputs.up && inputs.W_aerialReady && !isSpeedCapped(rotatedRight, false)) {
            carBody.angularVelocity.vsub(rotatedRight.scale(AERIAL_ROTATION_RATE), carBody.angularVelocity);    
        }
        if (inputs.down && inputs.S_aerialReady && !isSpeedCapped(rotatedRight, true)) {
            carBody.angularVelocity.vadd(rotatedRight.scale(AERIAL_ROTATION_RATE), carBody.angularVelocity);    
        }
        
        // Roll Control (Q/E)
        const rollRate = AERIAL_ROTATION_RATE * AIR_ROLL_MULTIPLIER;
        if (inputs.q && inputs.Q_aerialReady && !isSpeedCapped(rotatedForward, false)) {
            carBody.angularVelocity.vsub(rotatedForward.scale(rollRate), carBody.angularVelocity);
        }
        if (inputs.e && inputs.E_aerialReady && !isSpeedCapped(rotatedForward, true)) {
            carBody.angularVelocity.vadd(rotatedForward.scale(rollRate), carBody.angularVelocity);
        }

        // Yaw Control (A/D)
        if (inputs.left && inputs.A_aerialReady && !isSpeedCapped(rotatedUp, true)) {
            carBody.angularVelocity.vsub(rotatedUp.scale(AERIAL_ROTATION_RATE), carBody.angularVelocity);
        }
        if (inputs.right && inputs.D_aerialReady && !isSpeedCapped(rotatedUp, false)) {
            carBody.angularVelocity.vadd(rotatedUp.scale(AERIAL_ROTATION_RATE), carBody.angularVelocity);
        }

        // Apply air resistance to rotation
        carBody.angularVelocity.scale(0.99, carBody.angularVelocity);
    }

function resetCameraInstant() {
    cameraYaw = 0;
    cameraYawDir.set(0, 0, -1);
}

function updateCamera(delta) {
    if (!carBody) return;

    let targetPos = new THREE.Vector3();
    let lookAtPos = new THREE.Vector3();
    
    // Smoothness factor (higher is smoother)
    const smoothFactor = 8 * delta; 
    
    if (gameState === 'replay') {
        // Look at the goal explosion point
        lookAtPos.copy(replayGoalPos);
        // Position camera behind the blue goal
        targetPos.set(0, GOAL_HEIGHT * 2, BLUE_GOAL_LINE - FIELD_L * 0.1); 
        camera.position.lerp(targetPos, 0.1);
        camera.lookAt(lookAtPos);
        return;
    }

    if (cameraMode === 'car') {
        const CAMERA_DISTANCE = 15 * SCALE_FACTOR;
        const CAMERA_HEIGHT = 5 * SCALE_FACTOR;
        const CAMERA_OFFSET_Z = 10 * SCALE_FACTOR;
        
        // Get car forward direction
        const carForward = new CANNON.Vec3(0, 0, -1);
        carBody.quaternion.vmult(carForward, carForward);
        carForward.y = 0;
        carForward.normalize();
        
        // Calculate target camera position (behind and slightly above the car)
        targetPos.copy(carBody.position).vsub(carForward.scale(CAMERA_DISTANCE), targetPos);
        targetPos.y = carBody.position.y + CAMERA_HEIGHT;
        
        // Smoothly move camera
        camera.position.lerp(targetPos, smoothFactor);
        
        // Look at point (slightly in front of the car)
        lookAtPos.copy(carBody.position).vadd(carForward.scale(CAMERA_OFFSET_Z), lookAtPos);
        camera.lookAt(lookAtPos);

    } else if (cameraMode === 'ball') {
        const BALL_CAM_DISTANCE = 35 * SCALE_FACTOR;
        const BALL_CAM_HEIGHT = 15 * SCALE_FACTOR;

        // Vector from car to ball
        const toBall = new THREE.Vector3().copy(ballBody.position).sub(carMesh.position);
        toBall.y = 0;
        toBall.normalize();

        // Target camera position (behind car, offset from the car-to-ball vector)
        targetPos.copy(carBody.position);
        targetPos.sub(toBall.multiplyScalar(BALL_CAM_DISTANCE));
        targetPos.y = carBody.position.y + BALL_CAM_HEIGHT;

        // Smoothly move camera
        camera.position.lerp(targetPos, smoothFactor);

        // Always look at the ball
        lookAtPos.copy(ballBody.position);
        camera.lookAt(lookAtPos);
    }
}

function updatePhysics() {
    // Determine Time Step (fixed 60 FPS)
    const fixedTimeStep = 1 / 60; 
    world.step(fixedTimeStep);

    // Update car mesh position
    carMesh.position.copy(carBody.position);
    carMesh.quaternion.copy(carBody.quaternion);

    // Update ball mesh position
    ballMesh.position.copy(ballBody.position);
    ballMesh.quaternion.copy(ballBody.quaternion);
    
    // Update bot mesh position
    if (botBody) {
        botMesh.position.copy(botBody.position);
        botMesh.quaternion.copy(botBody.quaternion);
    }
}


function updateBotAI() {
    if (!botBody || gameMode !== 'bot1v1') return;

    // Reset bot inputs
    botInputs.up = false;
    botInputs.down = false;
    botInputs.left = false;
    botInputs.right = false;
    botInputs.shift = false;

    // --- CONSTANTS & VECTORS ---
    
    // Orange Bot Goal Line (Z position the bot needs to defend, +Z side)
    const ORANGE_GOAL_LINE_Z = FIELD_L * 0.3; 
    // Blue Goal Line (Z position the bot needs to attack, -Z side)
    const BLUE_GOAL_LINE_Z = -FIELD_L * 0.3; 

    const BOT_Z = botBody.position.z;
    const BOT_X = botBody.position.x;

    // Vector from bot to ball (XZ plane only)
    const toBall = new CANNON.Vec3(
        ballBody.position.x - BOT_X,
        0,
        ballBody.position.z - BOT_Z
    );
    const toBallLength = toBall.length();

    // Get the bot's current forward direction (XZ plane only)
    const forward = botBody.quaternion.vmult(new CANNON.Vec3(0, 0, -1));
    forward.y = 0;
    forward.normalize();

    // Angle between forward direction and vector to ball (Angle of error)
    const angleToBall =
        Math.atan2(
            forward.x * toBall.z - forward.z * toBall.x,
            forward.x * toBall.x + forward.z * toBall.z
        );
        
    // --- 1. WALL AVOIDANCE (Unsticking) ---
    // Check if bot is past the opponent's goal line AND pushing into the wall
    const isStuckAtWall = (BOT_Z < BLUE_GOAL_LINE_Z - 5) && (forward.z < -0.5);

    if (isStuckAtWall) {
        // Reverse to unstick
        botInputs.down = true; 
        botInputs.left = false;
        botInputs.right = false;
        return; // Exit AI logic this frame to focus on unsticking
    }

    // --- 2. CORE CHASE LOGIC ---

    // The preferred position is behind the ball (closer to the bot's own goal, +Z side)
    const desiredZ = ballBody.position.z + 5; // Target slightly past the ball towards its goal
    
    // Check if the bot is on the wrong side of the ball (closer to the Blue goal/back of the ball)
    const isBehindBall = BOT_Z > ballBody.position.z; 

    if (isBehindBall) {
        // Attack Mode: Drive straight toward the ball
        
        // Steering: Adjust angle to point towards the ball
        if (angleToBall > 0.1) botInputs.left = true;
        else if (angleToBall < -0.1) botInputs.right = true;
        
        // Drive: Go forward
        botInputs.up = true;
        
    } else {
        // Positional Correction: Bot is too far forward (closer to the Blue goal than the ball)

        // Target: Move back to the desired Z-position behind the ball
        const toDesiredPos = new CANNON.Vec3(0, 0, desiredZ - BOT_Z); 
        
        // Calculate the angle to face the desired position 
        const angleToDesiredPos =
            Math.atan2(
                forward.x * toDesiredPos.z - forward.z * toDesiredPos.x,
                forward.x * toDesiredPos.x + forward.z * toDesiredPos.z
            );
            
        // Steering: Turn toward the desired Z position (away from the ball)
        if (angleToDesiredPos > 0.1) botInputs.left = true;
        else if (angleToDesiredPos < -0.1) botInputs.right = true;

        // Drive: Reverse to get behind the ball
        botInputs.down = true;
    }
    
    // --- 3. BOOST ---
    if (toBallLength > 60 && botInputs.up) { // Only boost if driving forward and far
        botInputs.shift = true;
    }
}


function animate() {
    requestAnimationFrame(animate);
    if(!gameStarted) return;

    const delta = clock.getDelta();

    if(gameState === 'replay') {
        if(replayIndex < replayFrames.length){
            const frame = replayFrames[replayIndex];
            
            // 1. Load Player Car (Index 0)
            carBody.position.copy(frame.cars[0].pos);
            carBody.quaternion.copy(frame.cars[0].quat);
            
            // 2. Load Ball
            ballBody.position.copy(frame.ball.pos);
            ballBody.quaternion.copy(frame.ball.quat);
            
            // 3. Load Bot Car (Index 1)
            if (gameMode === 'bot1v1' && botBody && frame.cars.length > 1) {
                botBody.position.copy(frame.cars[1].pos); // Bot is always index 1
                botBody.quaternion.copy(frame.cars[1].quat);
            }
            
            replayIndex++;
            updateCamera(delta);
        } else {
            // End of replay, wait for timer
            replayTimer -= delta;
            updateCamera(delta);
            if (replayTimer <= 0) {
                resetGame();
            }
        }
    } else {
        updatePhysics();
        checkGoal();
        recordReplayFrame();

        if (gameMode === 'bot1v1') {
            updateBotAI();
            applyCarControls(botBody, botInputs);
        }
        
        applyCarControls(carBody, inputs);

        const isCarOnGround = carBody.position.y < (CAR_SIZE.h * 1.5);
        if (!isCarOnGround && !isFlipping) {
            updateAerialControls();
        } else {
            // Apply damping after flip ends
            carBody.angularDamping = 0.9;
            hasDoubleJumped = false;
        }

        if (isFlipping) {
            flipTimer -= delta;
            if (flipTimer <= 0) {
                isFlipping = false;
            }
        }
        
        updateCamera(delta);
    }

    renderer.render(scene, camera);
}


// Particle system for goal explosion
let particleSystem;
let particlesData = [];
const particleCount = 100;
const explosionDuration = 1.5;

function createGoalExplosion(position, color) {
    // Remove old system if it exists
    if (particleSystem) {
        scene.remove(particleSystem);
        particleSystem.geometry.dispose();
        particleSystem.material.dispose();
    }

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);

    const colorObj = new THREE.Color(color);

    for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        
        // Initial position is at the goal
        positions[i3 + 0] = position.x;
        positions[i3 + 1] = position.y;
        positions[i3 + 2] = position.z;

        colors[i3 + 0] = colorObj.r;
        colors[i3 + 1] = colorObj.g;
        colors[i3 + 2] = colorObj.b;

        // Random velocity vector (high impulse)
        const velX = (Math.random() - 0.5) * 60;
        const velY = Math.random() * 80 + 20; // Upwards bias
        const velZ = (Math.random() - 0.5) * 60;
        
        particlesData.push({
            velocity: new THREE.Vector3(velX, velY, velZ),
            startTime: performance.now() / 1000,
            originalPosition: new THREE.Vector3(position.x, position.y, position.z)
        });
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 5,
        transparent: true,
        opacity: 1.0,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthTest: true
    });

    particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);
}

function updateParticles() {
    if (!particleSystem) return;

    const currentTime = performance.now() / 1000;
    const positions = particleSystem.geometry.attributes.position.array;
    
    let activeParticles = 0;

    for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        const data = particlesData[i];
        const timeElapsed = currentTime - data.startTime;

        if (timeElapsed < explosionDuration) {
            // Apply physics (basic gravity)
            const g = -150; // Gravity constant from CANNON.js
            
            // Calculate new position using kinematic equation: P = P0 + V0*t + 0.5*a*t^2
            positions[i3 + 0] = data.originalPosition.x + data.velocity.x * timeElapsed;
            positions[i3 + 1] = data.originalPosition.y + data.velocity.y * timeElapsed + 0.5 * g * timeElapsed * timeElapsed;
            positions[i3 + 2] = data.originalPosition.z + data.velocity.z * timeElapsed;

            // Fade out the particle
            particleSystem.material.opacity = 1.0 - (timeElapsed / explosionDuration);
            activeParticles++;
        } else {
            // Hide particle by moving it far away
            positions[i3 + 1] = -1000;
        }
    }
    
    particleSystem.geometry.attributes.position.needsUpdate = true;

    if (activeParticles === 0) {
        scene.remove(particleSystem);
        particleSystem = null;
    }
}

// Global clock for delta time calculation
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    if(!gameStarted) return;

    const delta = clock.getDelta();
    updateParticles(); // Update particles every frame

    if(gameState === 'replay') {
        if(replayIndex < replayFrames.length){
            const frame = replayFrames[replayIndex];
            
            // 1. Load Player Car (Index 0)
            carBody.position.copy(frame.cars[0].pos);
            carBody.quaternion.copy(frame.cars[0].quat);
            
            // 2. Load Ball
            ballBody.position.copy(frame.ball.pos);
            ballBody.quaternion.copy(frame.ball.quat);
            
            // 3. Load Bot Car (Index 1)
            if (gameMode === 'bot1v1' && botBody && frame.cars.length > 1) {
                botBody.position.copy(frame.cars[1].pos); // Bot is always index 1
                botBody.quaternion.copy(frame.cars[1].quat);
            }
            
            replayIndex++;
            updateCamera(delta);
        } else {
            // End of replay, wait for timer
            replayTimer -= delta;
            updateCamera(delta);
            if (replayTimer <= 0) {
                resetGame();
            }
        }
    } else {
        updatePhysics();
        checkGoal();
        recordReplayFrame();

        if (gameMode === 'bot1v1') {
            updateBotAI();
            applyCarControls(botBody, botInputs);
        }
        
        applyCarControls(carBody, inputs);

        const isCarOnGround = carBody.position.y < (CAR_SIZE.h * 1.5);
        if (!isCarOnGround && !isFlipping) {
            updateAerialControls();
        } else {
            // Apply damping after flip ends
            carBody.angularDamping = 0.9;
            hasDoubleJumped = false;
        }

        if (isFlipping) {
            flipTimer -= delta;
            if (flipTimer <= 0) {
                isFlipping = false;
            }
        }
        
        updateCamera(delta);
    }

    renderer.render(scene, camera);
}


function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    // Re-check and update joystick visibility/position on resize if needed
    // This is handled passively by the setupMobileControls check, but can be forced here:
    if (document.getElementById('joystick').style.display !== 'none' && !('ontouchstart' in window)) {
         // If a desktop user toggles it on, we want it to stay on.
    } else {
        // Otherwise, hide it if the window is large and it's not a touch device.
    }
}


function recordReplayFrame() {
    if (gameState !== 'playing') return;

    // Save positions + rotations of ball and car(s)
    const frame = {
        ball: {
            pos: ballBody.position.clone(),
            quat: ballBody.quaternion.clone(),
        },
        cars: [
            {
                pos: carBody.position.clone(),
                quat: carBody.quaternion.clone(),
            }
        ]
    };
    
    if (gameMode === 'bot1v1' && botBody) {
        frame.cars.push({
            pos: botBody.position.clone(),
            quat: botBody.quaternion.clone(),
        });
    }

    replayBuffer.push(frame);

    // Keep buffer length fixed (only last REPLAY_LENGTH seconds)
    if (replayBuffer.length > REPLAY_LENGTH * REPLAY_FPS) {
        replayBuffer.shift();
    }
}


// TWEAK 4: Setup mobile controls function
// --- MOBILE/JOYSTICK CONTROLS LOGIC ---

function setupMobileControls() {
    const joystick = document.getElementById('joystick');
    const stick = document.getElementById('stick');
    const joystickRadius = 70; // Half of 140px width/height
    
    // Check if controls should be visible based on initial state (which is currently false, and toggled via settings)
    if (!mobileControlsEnabled) {
        joystick.style.display = 'none';
    } else {
        joystick.style.display = 'block';
        joystick.style.bottom = '20px'; // Position it on the bottom left
        joystick.style.left = '20px';
    }
    
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let currentTouchId = null;

    function startDrag(e) {
        if (!mobileControlsEnabled) return;

        e.preventDefault();
        // Check if another touch is already dragging the joystick (multi-touch handling)
        if (isDragging) return; 

        isDragging = true;
        
        const touch = e.touches ? e.touches[0] : e;
        currentTouchId = e.touches ? touch.identifier : null;
        
        // Position the dynamic joystick where the touch occurred
        joystick.style.left = (touch.clientX - joystickRadius) + 'px';
        joystick.style.top = (touch.clientY - joystickRadius) + 'px';
        
        startX = touch.clientX;
        startY = touch.clientY;
    }

    function moveDrag(e) {
        if (!isDragging || !mobileControlsEnabled) return;
        e.preventDefault();
        
        let touch = e.touches ? Array.from(e.touches).find(t => t.identifier === currentTouchId) : e;
        if (!touch) touch = e; // Fallback for mouse/pointer

        let deltaX = touch.clientX - startX;
        let deltaY = touch.clientY - startY;
        
        let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const angle = Math.atan2(deltaY, deltaX);

        // Cap distance to the joystick radius
        if (distance > joystickRadius) {
            distance = joystickRadius;
            deltaX = Math.cos(angle) * joystickRadius;
            deltaY = Math.sin(angle) * joystickRadius;
        }

        // Move the stick visual
        stick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

        // --- ANALOG INPUT MAPPING ---
        // Y-axis for Drive: -1.0 (reverse) to 1.0 (forward)
        // Inverted: moving UP (negative Y delta) is forward (positive driveAnalog)
        inputs.driveAnalog = THREE.MathUtils.clamp(-deltaY / joystickRadius, -1, 1);
        
        // X-axis for Steer: -1.0 (left) to 1.0 (right)
        inputs.steerAnalog = THREE.MathUtils.clamp(deltaX / joystickRadius, -1, 1);
    }

    function endDrag(e) {
        if (!mobileControlsEnabled) return;
        // If using touch and the lifted touch is not the one controlling the stick, ignore
        if (e.changedTouches && isDragging && !Array.from(e.changedTouches).some(t => t.identifier === currentTouchId)) {
            return;
        }

        if (!isDragging) return;
        isDragging = false;
        currentTouchId = null;
        
        // Snap stick back to center and reset analog inputs
        stick.style.transform = `translate(0, 0)`;
        inputs.driveAnalog = 0.0;
        inputs.steerAnalog = 0.0;
        
        // Reset joystick position
        joystick.style.left = '20px';
        joystick.style.top = ''; 
        joystick.style.bottom = '20px'; 
    }

    // Add pointer/touch event listeners
    joystick.addEventListener('pointerdown', startDrag);
    document.addEventListener('pointermove', moveDrag);
    document.addEventListener('pointerup', endDrag);
    joystick.addEventListener('touchstart', startDrag);
    document.addEventListener('touchmove', moveDrag);
    document.addEventListener('touchend', endDrag);
}


const menuOverlay = document.getElementById('menuOverlay');
const FreeBtn = document.getElementById('FreeplayBtn');
const botBtn = document.getElementById('1v1Btn')
const settingsBtn = document.getElementById('settingsBtn');
const quitBtn = document.getElementById('quitBtn');

const escEvent = new KeyboardEvent("keydown", { key: "Escape" });

document.getElementById('pauseBtn').addEventListener('click', () => {
    window.dispatchEvent(escEvent);
});


FreeBtn.addEventListener('click', () => {
    menuOverlay.style.display = 'none';
    gameStarted = true;
    gameMode = 'freeplay';
    resetGame();
});

botBtn.addEventListener('click', () => {
    menuOverlay.style.display = 'none';
    gameStarted = true;
    gameMode = 'bot1v1';

    if (!botBody) createBotCar();
    resetGame();
});


settingsBtn.addEventListener('click', () => {
    const choice = confirm(
        "Mobile Controls are currently " + 
        (mobileControlsEnabled ? "ON" : "OFF") + 
        "\n\nPress OK to toggle."
    );

    if (choice) {
        mobileControlsEnabled = !mobileControlsEnabled;
        setupMobileControls(); // Re-run setup to show/hide the joystick
    }
});


quitBtn.addEventListener('click', () => {
    alert("Quitting game...");
    window.location.reload();
});

window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        if(menuOverlay.style.display === 'flex'){
            menuOverlay.style.display = 'none';
            gameStarted = true;
        } else {
            menuOverlay.style.display = 'flex';
            gameStarted = false;
        }
    }
});
</script>
</body>
</html>
